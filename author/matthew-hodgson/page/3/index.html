<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="twitter:widgets:csp" content="on" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="twitter:site" content="@matrixdotorg" />
    <meta name="twitter:creator" content="@matrixdotorg" />

    <title>Matrix.org - Matthew Hodgson</title>
    <link rel="shortcut icon" href="/assets/favicon.ico" />
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />
    <link rel="stylesheet" href="/style.css" />

    
<link rel="alternate" type="application/rss+xml" title="RSS" href="/author/matthew-hodgson/atom.xml">
</head>

<body>
    
    <header class="site-header">
    <a href="/" class="brand">
        <img src="/images/matrix-logo-white.svg" alt="Matrix logo">
    </a>
    <input id="site-header-dropdown-checkbox" type="checkbox" class="dropdown-checkbox" aria-hidden="true">
    <label for="site-header-dropdown-checkbox" class="dropdown-button">&#xe602;</label>
    <label for="site-header-dropdown-checkbox" class="page-overlay"></label>
    <nav>
        
        
        <a href="&#x2F;about&#x2F;" class="
            ">
            About
        </a>
        
        
        
        <a href="&#x2F;blog&#x2F;" class="
            ">
            Blog
        </a>
        
        
        
        <a href="&#x2F;docs&#x2F;" class="
            ">
            Documentation
        </a>
        
        
        
        
        
        <div class="section-wrap">
            <input id="ecosystem-submenu-checkbox" type="checkbox" class="submenu-checkbox" aria-hidden="true"
                >
            <label for="ecosystem-submenu-checkbox" class="submenu-title">Ecosystem <div class="arrow">
                </div></label>

            <div class="section-submenu-wrap">
                <div class="section-submenu">
                    
                    
                    <a href="&#x2F;ecosystem&#x2F;clients&#x2F;">Clients</a>
                    
                    
                    <a href="&#x2F;ecosystem&#x2F;bridges&#x2F;">Bridges</a>
                    
                    
                    <a href="&#x2F;ecosystem&#x2F;servers&#x2F;">Servers</a>
                    
                    <a href="&#x2F;ecosystem&#x2F;integrations&#x2F;">Integrations</a>
                    
                    <a href="&#x2F;ecosystem&#x2F;sdks&#x2F;">SDKs</a>
                    
                    <a href="&#x2F;ecosystem&#x2F;hosting&#x2F;">Hosting</a>
                    
                </div>
            </div>
        </div>
        
        
        
        <a href="&#x2F;podcasts&#x2F;" class="
            ">
            Podcasts
        </a>
        
        
        
        <a href="https:&#x2F;&#x2F;shop.matrix.org" class="
            ">
            Shop
        </a>
        
        
        
        <a href="&#x2F;try-matrix&#x2F;" class="primary
            ">
            Try Matrix
        </a>
        
        
    </nav>
</header>


    <main>
        
<div id="taxonomy-single">
    <div class="content">
        <header>
            <h1>Matthew Hodgson</h1>
            149 posts tagged with "Matthew Hodgson" <a href="/author">(See all Author)</a>
            
        </header>

        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;12&#x2F;18&#x2F;introducing-cerulean&#x2F;" title="Introducing Cerulean">Introducing Cerulean</a></h2>
                <span>
                    18.12.2020 00:00
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi all,</p>
<p>We have a bit of an unexpected early Christmas present for you today…</p>
<p>Alongside all the normal business-as-usual Matrix stuff, we’ve found some time to do a mad science experiment over the last few weeks - to test the question: “Is it possible to build a serious Twitter-style decentralised microblogging app using Matrix?”</p>
<p>It turns out the answer is a firm “yes” - and as a result we’d like to present a <strong>very</strong> early sneak preview of <a href="https://cerulean.matrix.org">Cerulean</a>: a highly experimental new microblogging app for Matrix, complete with first-class support for arbitrarily nested threading, with both Twitter-style (“vertical”) and HN/Reddit-style (“horizontal”) layout… and mobile web support!</p>
<p><a href="https://cerulean.matrix.org/@kegan:dendrite.matrix.org/!bHe21S4P3axekSRD:dendrite.matrix.org/$0QE6vqMZiS9169Y-3C84dkQui-1G5uG2eGFsYzPrhx8"><img src="https://matrix.org/blog/img/2020-12-18-cerulean-screenshot.jpg" alt="Cerulean screenie" /></a></p>
<p>Cerulean is unusual in many ways:</p>
<ul>
<li>It’s (currently) <a href="https://github.com/matrix-org/cerulean">a very minimal javascript app</a> - only 2,500 lines of code.</li>
<li>It has zero dependencies (other than React).
<ul>
<li>This is to show just how simple a fairly sophisticated Matrix client can be...</li>
<li>...and so the code can be easily understood by folks unfamiliar with Matrix...</li>
<li>...and so we can iterate fast while figuring out threading...</li>
<li>...and because none of the SDKs support threading yet :D</li>
</ul>
</li>
<li>It relies on <a href="https://github.com/matrix-org/matrix-doc/pull/2836">MSC2836: Threading</a> - our highly experimental Matrix Spec Change to extend relationships (as used by reaction &amp; edit aggregations) to support free-form arbitrary depth threading.</li>
<li>As such, <strong>it only works on Dendrite</strong>, as that’s where we’ve been experimenting with implementing MSC2836.  (We’re now running an <a href="https://matrix.org/blog/2020/12/15/dendrite-2020-progress-update">official public Dendrite server instance</a> at dendrite.matrix.org though, which makes it easy to test - and our test Cerulean instance <a href="https://cerulean.matrix.org">https://cerulean.matrix.org</a> points at it by default).</li>
</ul>
<p>This is **very much a proof of concept.  **We’re releasing it today as a sneak preview so that intrepid Matrix experimenters can play with it, and to open up the project for contributions! (PRs welcome - it should be dead easy to hack on!).  Also, we give no guarantees about data durability: both Cerulean and dendrite.matrix.org are highly experimental; do not trust them yet with important data; we reserve the right to delete it all while we iterate on the design.</p>
<h3 id="what-can-it-do">What can it do?</h3>
<p>So for the first cut, we’ve implemented the minimal features to make this something you can just about use and play with for real :)</p>
<ul>
<li>Home view (showing recent posts from folks you follow)</li>
<li>Timeline view (showing the recent posts or replies from a given user)</li>
<li>Thread view (showing a post and its replies as a thread)</li>
<li>Live updating (It’s Matrix, after all! We’ve disabled it for guests though.)</li>
<li>Posting plain text and images</li>
<li>Fully decentralised thanks to Matrix (assuming you’re on Dendrite)</li>
<li>Twitter-style “Vertical” threading (replies form a column; you indent when someone forks the conversation)</li>
<li>HN/Reddit/Email-style “Horizontal” threading (each reply is indented; forks have the same indentation)</li>
<li>Basic Registration &amp; Login</li>
<li>Guest support (slightly faked with non-guest users, as Dendrite’s guest support isn’t finished yet)</li>
<li>Super-experimental proof-of-concept support for <a href="https://matrix.org/blog/2020/10/19/combating-abuse-in-matrix-without-backdoors">decentralised reputation filtering</a>(!) </li>
</ul>
<p>Obviously, there’s a huge amount of stuff needed for parity with a proper Twitter-style system:</p>
<ul>
<li>Configurable follows.  Currently the act of viewing someone’s timeline automatically follows them.  This is because Dendrite doesn’t peek over federation yet (but <a href="https://github.com/matrix-org/dendrite/pull/1391">it’s close</a>), so you have to join a room to view its contents - and the act of viewing someone’s timeline room is how you follow them in Cerulean. </li>
<li>Likes (i.e. plain old Matrix reactions, although we might need to finally sort out federating them as aggregations rather than individually, if people use them like they use them on Twitter!)</li>
<li>Retweets (dead easy)</li>
<li>Pagination / infinite scrolling (just need to hook it up)</li>
<li>Protect your posts (dead easy; you just switch your timeline room to invite-only!)</li>
<li>Show (some) replies to messages in the Home view</li>
<li>Show parent and sibling context as well as child context in the Thread view</li>
<li>Mentions (we need to decide how to notify folks when they’re mentioned - perhaps Matrix’s push notifications should be extended to let you subscribe to keywords for public rooms you’re not actually in?)</li>
<li>Notifications (although this is just because Dendrite doesn’t do notifs yet)</li>
<li>Search (again, just needs to be implemented in Dendrite - although how do you search beyond the data in your current homeserver? Folks are used to global search)</li>
<li>Hashtags (it’s just search, basically)</li>
<li>Symlinks (see below)</li>
<li>Figure out how to handle lost unthreaded messages (see below)</li>
<li>Offline support? (if we were using a proper Matrix SDK, we’d hopefully get this for free, but currently Cerulean doesn’t store any state locally at all).</li>
</ul>
<h3 id="how-does-it-work">How does it work?</h3>
<p>Every message you send using Cerulean goes into two Matrix rooms, dubbed the &quot;timeline&quot; room and the &quot;thread&quot; room. The &quot;timeline&quot; room (with an alias of <a href="https://matrix.to/#/#@matthew:dendrite.matrix.org">#@matthew:dendrite.matrix.org</a> or whatever your matrix id is) is a room with all of your posts and no one else's. The &quot;thread&quot; room is a normal Matrix room which represents the message thread itself. Creating a new &quot;Post&quot; will create a new &quot;thread&quot; room. Replying to a post will join the existing &quot;thread&quot; room and send a message into that room. MSC2836 is used to handle threading of messages in the &quot;thread” room - the replies refer to their parent via an m.relationship field in the event.</p>
<p>These semantics play nicely with existing Matrix clients, who will see one room per thread and a flattened chronological view of the thread itself (unless the client natively supports MSC2836, but none do yet apart from Cerulean). However, as Cerulean only navigates threaded messages with an m.reference relationship (eg it only ever uses the new /event_relationships API rather than /messages to pull in history), <strong>normal messages sent by Matrix into a thread or timeline room will not yet show up in Cerulean.</strong></p>
<p>In this initial version, Cerulean literally posts the message twice into both rooms - but we’re also experimenting with the idea of adding “symlinks” to Matrix, letting the canonical version of the event be in the timeline room, and then the instance of the event in the thread room be a ‘symlink’ to the one in the timeline.  This means that the threading metadata could be structured in the thread room, and let the user do things like turn their timeline private (or vice versa) without impacting the threading metadata.  We could also add an API to both post to timeline and symlink into a thread in one fell swoop, rather than manually sending two events.  It’d look something like this:</p>
<p><img src="https://matrix.org/blog/img/2020-12-18-cerulean-diagram.png" alt="Cerulean diagram" /></p>
<p>We also experimented with cross-room threading (letting Bob’s timeline messages directly respond to Alice’s timeline messages and vice versa), but it posed some nasty problems - for instance, to find out what cross-room replies a message has, you’d need to store forward references somehow which the replier would need permission to create.  Also, if you didn’t have access to view the remote room, the thread would break. So we’ve punted cross-room threading to a later MSC for now.</p>
<p>Needless to say, once we’re happy with how threading works at the protocol level, we’ll be looking at getting it into the UX of Element and mainstream Matrix chat clients too!</p>
<h3 id="what-s-with-the-decentralised-reputation-button">What’s with the decentralised reputation button?</h3>
<p>Cerulean is very much a test jig for new ideas (e.g. threading, timeline rooms, peeking), and we’re taking the opportunity to also use it as an experiment for our first forays into publishing and subscribing to reputation greylists; giving users the option to filter out content by default they might not want to see… but doing so on their own terms by subscribing to whatever reputation feed they prefer, while clearly visualising the filtering being applied.  In other words, this is the first concrete experimental implementation of the work proposed in the second half of <a href="https://matrix.org/blog/2020/10/19/combating-abuse-in-matrix-without-backdoors">Combating Abuse in Matrix without Backdoors</a>.  This is super early days, and we haven’t even published a proto-MSC for the event format being used, but if you’re particularly interested in this domain it’s easy enough to figure out - just head over to <a href="https://matrix.to/#/#nsfw:dendrite.matrix.org">#nsfw:dendrite.matrix.org</a> (warning: not actually NSFW, yet) and look in /devtools to see what’s going on.</p>
<p>So, there you have it - further evidence that Matrix is not just for Chat, and a hopefully intriguing taste of the shape of things to come! Please check out the demo at <a href="https://cerulean.matrix.org">https://cerulean.matrix.org</a> or try playing with your own from <a href="https://github.com/matrix-org/cerulean">https://github.com/matrix-org/cerulean</a>, and then head over to <a href="https://matrix.to/#/#cerulean:matrix.org">#cerulean:matrix.org</a> and let us know what you think! :)</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;12&#x2F;07&#x2F;gitter-now-speaks-matrix&#x2F;" title="Gitter now speaks Matrix!">Gitter now speaks Matrix!</a></h2>
                <span>
                    07.12.2020 00:00
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi all,</p>
<p>It’s been just over 2 months since we revealed that <a href="https://matrix.org/blog/2020/09/30/welcoming-gitter-to-matrix">Gitter was going to join Matrix</a> - and
we are incredibly proud to announce that Gitter has officially turned on true native Matrix connectivity:
<strong>all public Gitter rooms are now available natively via Matrix, and all Gitter users now natively exist on Matrix.</strong>
So, if you wanted to join the official Node.js language support room at <a href="https://gitter.im/nodejs/node">https://gitter.im/nodejs/node</a>
from Matrix, just head over to <a href="https://matrix.to/#/#nodejs_node:gitter.im">#nodejs_node:gitter.im</a> and *boom*, you’re in!</p>
<p>This means Gitter is now running a Matrix homeserver at gitter.im which exposes all the active public rooms - so if you go to the the room directory in Element (for instance) and select gitter.im as a homeserver, you can jump straight in:</p>
<p><img src="https://matrix.org/blog/img/2020-12-07-gitter-roomdir.png" alt="Gitter room directory" /></p>
<p>Once you’re in, you can chat back and forth transparently between users on the Gitter side and the Matrix side, and you no longer have the ugly “Matrixbot” user faking the messages back and forth - these are ‘real’ users talking directly to one another, and every public msg in every public room is now automatically exposed into Matrix.</p>
<p><img src="https://matrix.org/blog/img/2020-12-07-gitter-matrix.gif" alt="Gitter and Matrix going native!" /></p>
<p>So, suddenly all the developer communities previously living only in Gitter (<a href="https://gitter.im/scala">Scala</a>, <a href="https://gitter.im/nodejs/home">Node</a>, <a href="https://gitter.im/webpack">Webpack</a>, <a href="https://gitter.im/angular">Angular</a>, <a href="https://gitter.im/rails">Rails</a> and thousands of others) are now available to anyone anywhere on Matrix - alongside communities bridged from Freenode and Slack; the native Matrix communities for Mozilla, KDE, GNOME communities etc. We’re hopeful that glueing everything together via Matrix will usher in a new age of open and defragmented dev collaboration, a bit like we used to have on IRC, back in the day.</p>
<p>This is also great news for mobile Gitter users - as the original mobile Gitter clients have been in a <a href="https://gitlab.com/gitlab-org/gitter/webapp/-/issues/2281">holding pattern for over a year</a>, and native Matrix support for Gitter means they are now officially deprecated in favour of Element (or indeed any other mobile Matrix client).</p>
<h2 id="what-features-are-ready">What features are ready?</h2>
<p>Now, this is the first cut of native Matrix support in Gitter: much of the time since Gitter joined Element has been spent migrating stuff over from Gitlab to Element, and it’s only really been a month of work so far in hooking up Matrix. As a result: all the important features work, but there’s also stuff that’s yet to land:</p>
<p>Features ready today:</p>
<ul>
<li>Ability to join rooms from Matrix via #org_repo:gitter.im</li>
<li>Bridging Edits, Replies (mapped to Threads on Gitter), Deletes, File transfer</li>
<li>Bridging Markdown &amp; Emoji</li>
</ul>
<p>What remains:</p>
<ul>
<li>Ability to send/receive Direct Messages</li>
<li>Ability to plumb existing Matrix rooms into Gitter natively</li>
<li>Ability to view past Gitter history from Matrix. This is planned thanks to <a href="https://github.com/matrix-org/matrix-doc/pull/2716">https://github.com/matrix-org/matrix-doc/pull/2716</a></li>
<li>Synchronising the full Gitter membership list to Matrix. Currently the membership syncs incrementally as people speak</li>
<li>Turning off the old Gitter bridge</li>
<li>Bridging emotes (/me support) (almost landed!)</li>
<li>Bridging read receipts</li>
<li>Synchronising room avatars</li>
<li>Bridge LaTeX</li>
</ul>
<p>Stuff we’re not planning to support:</p>
<ul>
<li>Ability to join arbitrary rooms on Matrix from Gitter. This could consume huge resources on Gitter, and we’re not in a rush to mirror all of Matrix into Gitter. This will get addressed when Gitter merges with Element into a pure Matrix client.</li>
<li>Bridging Reactions. Gitter doesn’t have these natively today, and rather than adding them to Gitter, we’d rather work on merging Gitter &amp; Element together.</li>
</ul>
<p>For more details, we strongly recommend checking out the <a href="https://gitlab.com/groups/gitterHQ/-/epics/10">native Matrix epic on Gitlab</a> for the unvarnished truth straight from the coal-face!</p>
<h2 id="how-do-you-make-an-existing-chat-system-talk-matrix">How do you make an existing chat system talk Matrix?</h2>
<p>In terms of the work which has gone into this - Gitter has been an excellent case study of how you can easily plug an existing large established chat system into Matrix.</p>
<p>At high level, the core work needed was as simple as:</p>
<ul>
<li>Add ‘virtual users’, so remote Matrix users can be modelled and represented in Gitter correctly: <a href="https://gitlab.com/gitterHQ/webapp/-/merge_requests/2027/diffs">https://gitlab.com/gitterHQ/webapp/-/merge_requests/2027/diffs</a>.
<ul>
<li>This can be accomplished by simply adding a <code>virtualUser</code> property to your chat message/post/tweet schema which holds the mxid, displayName, and avatar as an alternative to your <code>author</code> field. Then display the <code>virtualUser</code> whenever available over the <code>author</code>.</li>
</ul>
</li>
<li>Add an application service to Gitter to bridge traffic in &amp; out of Matrix: <a href="https://gitlab.com/gitterHQ/webapp/-/merge_requests/2041/diffs">https://gitlab.com/gitterHQ/webapp/-/merge_requests/2041/diffs</a>
<ul>
<li>This &quot;application service&quot; comes pre-packaged for you in many cases, so for example you can simply drop in a library like <a href="https://github.com/matrix-org/matrix-appservice-bridge">matrix-appservice-bridge</a> in a Node.js application, and all of the Matrix talking complexity is handled for you.</li>
</ul>
</li>
<li>Polish it!</li>
</ul>
<p>In practice, Eric (lead Gitter dev) laid out the waypoints of the full journey:</p>
<ol>
<li>First big step was to add the concept of virtual users to Gitter. We could also have created a new Gitter user for every new matrix ID that appears, but tagging them as virtual users is a bit cleaner.</li>
<li>Figuring out how to balance the Matrix traffic coming into/out of Gitter.
<ol>
<li>Spreading the inbound load comes for free via our existing load-balancer setup (ELB) where we already have 8 webapp servers running the various services of gitter.im. We just run the Matrix bridge on those servers alongside each web and api process, and then the load-balancer’s <code>matrix.gitter.im</code> spreads out to the servers.</li>
<li>Events from Matrix then hit the load balancer and reach one of the servers (no duplication when processing events).</li>
<li>If something on Gitter happens, the action occurs on one server and we just propagate it over to Matrix (no duplication or locking needed).</li>
</ol>
</li>
<li>We have realtime websockets and Faye subscriptions already in the app which are backed by Mongoose database hooks whenever something changes. We just tapped into the same thing to be able to bridge across new information to Matrix as we receive it on Gitter.</li>
<li>Hooking up the official Matrix bridging <a href="https://github.com/matrix-org/matrix-appservice-bridge">matrix-appservice-bridge</a> library to use Gitter’s existing MongoDB for storage instead of nedb.</li>
<li>Figuring out how to namespace the mxids of the gitter users:
<ol>
<li>It’s nice to have the mxid as human readable as possible instead of just the numerical userId in your service.</li>
<li>But if people can change their username in your service, you can’t change your mxid on Matrix. In the future, we’ll have portable accounts in Matrix to support this (<a href="https://github.com/matrix-org/matrix-doc/pull/2787">MSC2787</a>) but sadly these are still vapourware at this point.</li>
<li>If you naively just switch the user’s mxid when they rename their username, then you could end up leaking conversation history between mxids(!)</li>
<li>So we went with <code>@username-userid:gitter.im</code> for the Matrix ID to make it a bit more human readable but also unique so any renames can happen without affecting anything.</li>
</ol>
</li>
<li>For room aliases, we decided to change our <code>community/room</code> URI syntax to underscores for the room aliases, <code>#community_room:gitter.im</code></li>
<li>Figuring out how to bridge features correctly;
<ol>
<li>Emoji - mapping between <code>:shortcode:</code> and unicode emojis</li>
<li>Mapping between Gitter threaded conversations &lt;-&gt; Matrix replies</li>
<li>Mapping between Matrix mentions and Gitter mentions</li>
</ol>
</li>
<li>Keeping users and room data in sync
<ol>
<li>We haven’t gotten there yet, but the data comes through the same Mongoose hook and we can update the bridged data as they change on the Gitter end.</li>
</ol>
</li>
</ol>
<p>Meanwhile, the Matrix side of gitter.im is hosted by <a href="https://element.io/matrix-services">Element Matrix Services</a> and is a plain old Synapse, talking through to Gitter via the Application Service API. An alternative architecture would be to have got Gitter directly federating with Matrix by embedding a “homeserver library” into it (e.g. embedding <a href="https://github.com/matrix-org/dendrite">Dendrite</a>). However, given Dendrite is still beta and assumes it is storing its data itself (rather than persisting in an existing backend such as Gitter’s mongodb), we went for the simpler option to start with.</p>
<p>It’s been really interesting to see how this has played out week by week in the Gitter updates in This Week in Matrix: you can literally track the progress and see how the integration came to life between <a href="https://matrix.org/blog/2020/10/09/this-week-in-matrix-2020-10-09#gitter">Oct 9</a>, <a href="https://matrix.org/blog/2020/10/23/this-week-in-matrix-2020-10-23#gitter">Oct 23</a>, <a href="https://matrix.org/blog/2020/11/06/this-week-in-matrix-2020-11-06#gitter">Nov 6</a>, <a href="https://matrix.org/blog/2020/11/27/this-week-in-matrix-2020-11-27#gitter">Nov 27</a> and finally <a href="https://matrix.org/blog/2020/12/04/this-week-in-matrix-2020-12-04#gitter">Dec 4</a>.</p>
<p>Huge thanks go to Eric Eastwood, the lead dev of Gitter and mastermind behind the project - and also to Half-Shot and Christian who’ve been providing all the support and review from the Matrix bridging team.</p>
<h2 id="what-s-next">What’s next?</h2>
<p>First and foremost we’re going to be working through the “What remains” section of the list above: killing off the old bridge, sorting out plumbed rooms, hooking up DMs, importing old Gitter history into Matrix, etc. This should then give us an exceptionally low impedance link between Gitter &amp; Matrix.</p>
<p>Then, <a href="https://matrix.org/blog/2020/09/30/welcoming-gitter-to-matrix">as per our original announcement</a>, the plan is:</p>
<p><em>In the medium/long term, it’s simply not going to be efficient for the combined Element/Gitter team to split our efforts maintaining two high-profile Matrix clients. Our plan is instead to merge Gitter’s features into Element (or next generations of Element) itself and then - if and only if Element has achieved parity with Gitter - we expect to upgrade the deployment on gitter.im to a Gitter-customised version of Element. The inevitable side-effect is that we’ll be adding new features to Element rather than Gitter going forwards.</em></p>
<p>Now, that means implementing some features in Matrix/Element to match...</p>
<ul>
<li>Instant live room peeking (less than a second to load the webapp into a live-view of a massive room with 20K users!!)</li>
<li>Seamless onboarding thanks to using GitLab &amp; GitHub for accounts</li>
<li>Curated hierarchical room directory</li>
<li>Magical creation of rooms on demand for every GitLab and GitHub project ever</li>
<li>GitLab/GitHub activity as a first-class citizen in a room’s side-panel</li>
<li>Excellent search-engine-friendly static content and archives</li>
<li>KaTeX support for Maths communities</li>
<li>Threads!</li>
</ul>
<p>...and this work is in full swing:</p>
<ul>
<li>We have a proposal for fast peeking (via lazy-loading state over federation) at <a href="https://github.com/matrix-org/matrix-doc/blob/matthew/msc2775/proposals/2775-lazy-loading-over-federation.md">MSC2775</a> and the new peek APIs at <a href="https://github.com/matrix-org/matrix-doc/blob/matthew/msc2753/proposals/2753-peeking-via-sync-v2.md">MSC2753</a> and <a href="https://github.com/matrix-org/matrix-doc/blob/matthew/msc2444/proposals/2444-peeking-over-federation-peek-api.md">MSC2444</a> (and even implemented by Dendrite)</li>
<li>Social Login for seamless onboarding via GitLab, GitHub &amp; friends is almost landed in Element: <a href="https://github.com/matrix-org/matrix-react-sdk/pull/5426">https://github.com/matrix-org/matrix-react-sdk/pull/5426</a></li>
<li>Spaces gives a curated hierarchical room directory: <a href="https://github.com/vector-im/roadmap/issues/2">https://github.com/vector-im/roadmap/issues/2</a></li>
<li>KaTeX support landed in Element Web a few weeks ago thanks to <a href="https://github.com/akissinger">akissinger</a> and <a href="https://github.com/thosgood">thosgood</a></li>
<li>Threads are on the horizon, thanks to <a href="https://github.com/matrix-org/matrix-doc/pull/2836">MSC2836</a>.</li>
</ul>
<p>The only bits which aren’t already progressing yet are tighter GL/GH integration, and better search engine optimised static archives.</p>
<p>So, the plan is to get cracking on the rest of the feature parity, then merge Gitter &amp; Element together - and meanwhile continue getting the rest of the world into Matrix :)</p>
<p>We live in exciting times: open standards-based interoperable communication is on the rise again, and we hope Gitter’s new life in Matrix is the beginning of a new age of cross-project developer collaboration, at last escaping the fragmentation we’ve suffered over the last few years.</p>
<p>Finally, please do give feedback via <a href="https://gitter.im/matrix-org/gitter">Gitter</a> or <a href="https://matrix.to/#/#matrix-org_gitter:gitter.im">Matrix</a> (or <a href="mailto:matrix@matrix.org">mail</a>!) on the integration and where you’d like to see it go next!</p>
<p>Thanks for flying Matrix and Gitter,</p>
<p>-- The Matrix Team</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;11&#x2F;16&#x2F;dendrite-0-3-0-released&#x2F;" title="Dendrite 0.3.0 released">Dendrite 0.3.0 released</a></h2>
                <span>
                    16.11.2020 17:44
                    —
                    <a href="/category/releases">
                        Releases
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi all,</p>
<p>Heads up that we just cut another beta release of Dendrite - now at 0.3.0!</p>
<p>This is a really fun release given almost all the changes are contributed from
the wider community - so huge thanks to <a href="https://github.com/S7evinK">S7evinK</a>,
<a href="https://github.com/MayeulC">MayeulC</a> and <a href="https://github.com/felix">felix</a>!</p>
<p>The main new feature is full Read Receipt support thanks to S7evinK, which
makes an enormous perceptual improvement when using Dendrite - so especial
thanks are due there :)</p>
<p>So, if you're interested in helping us test, please spin up a copy from
https://github.com/matrix-org/dendrite and let us know how it goes - and if you're
already running one, now is an excellent time to upgrade!</p>
<p>Full changelog (including 0.2.1, which we forgot to blog about) follows:</p>
<h2 id="dendrite-0-3-0-2020-11-16">Dendrite 0.3.0 (2020-11-16)</h2>
<h3 id="features">Features</h3>
<ul>
<li>Read receipts (both inbound and outbound) are now supported (contributed by <a href="https://github.com/S7evinK">S7evinK</a>)</li>
<li>Forgetting rooms is now supported (contributed by <a href="https://github.com/S7evinK">S7evinK</a>)</li>
<li>The <code>-version</code> command line flag has been added (contributed by <a href="https://github.com/S7evinK">S7evinK</a>)</li>
</ul>
<h3 id="fixes">Fixes</h3>
<ul>
<li>User accounts that contain the <code>=</code> character can now be registered</li>
<li>Backfilling should now work properly on rooms with world-readable history visibility (contributed by <a href="https://github.com/MayeulC">MayeulC</a>)</li>
<li>The <code>gjson</code> dependency has been updated for correct JSON integer ranges</li>
<li>Some more client event fields have been marked as omit-when-empty (contributed by <a href="https://github.com/S7evinK">S7evinK</a>)</li>
<li>The <code>build.sh</code> script has been updated to work properly on all POSIX platforms (contributed by <a href="https://github.com/felix">felix</a>)</li>
</ul>
<h2 id="dendrite-0-2-1-2020-10-22">Dendrite 0.2.1 (2020-10-22)</h2>
<h3 id="fixes-1">Fixes</h3>
<ul>
<li>Forward extremities are now calculated using only references from other extremities, rather than including outliers, which should fix cases where state can become corrupted (<a href="https://github.com/matrix-org/dendrite/pull/1556">#1556</a>)</li>
<li>Old state events will no longer be processed by the sync API as new, which should fix some cases where clients incorrectly believe they have joined or left rooms (<a href="https://github.com/matrix-org/dendrite/pull/1548">#1548</a>)</li>
<li>More SQLite database locking issues have been resolved in the latest events updater (<a href="https://github.com/matrix-org/dendrite/pull/1554">#1554</a>)</li>
<li>Internal HTTP API calls are now made using H2C (HTTP/2) in polylith mode, mitigating some potential head-of-line blocking issues (<a href="https://github.com/matrix-org/dendrite/pull/1541">#1541</a>)</li>
<li>Roomserver output events no longer incorrectly flag state rewrites (<a href="https://github.com/matrix-org/dendrite/pull/1557">#1557</a>)</li>
<li>Notification levels are now parsed correctly in power level events (<a href="https://github.com/matrix-org/gomatrixserverlib/pull/228">gomatrixserverlib#228</a>, contributed by <a href="https://github.com/Pestdoktor">Pestdoktor</a>)</li>
<li>Invalid UTF-8 is now correctly rejected when making federation requests (<a href="https://github.com/matrix-org/gomatrixserverlib/pull/229">gomatrixserverlib#229</a>, contributed by <a href="https://github.com/Pestdoktor">Pestdoktor</a>)</li>
</ul>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;11&#x2F;03&#x2F;how-we-fixed-synapse-s-scalability&#x2F;" title="How we fixed Synapse&#x27;s scalability!">How we fixed Synapse&#x27;s scalability!</a></h2>
                <span>
                    03.11.2020 00:00
                    —
                    <a href="/category/releases">
                        Releases
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi all,</p>
<p>We had a major break-through in Synapse 1.22 which we want to talk about in
more detail: <strong>Synapse now scales horizontally across multiple python
processes.</strong></p>
<p>Horizontal scaling means that you can support more users and traffic by adding
in more python processes (spread over more machines, if necessary) without
there being a single bottleneck which all the traffic is passing through - as
opposed to vertical scaling where you make things go faster overall by making
the bottleneck go faster.</p>
<p>After many years of having to vertically scale Synapse (by trying to make the
main process go faster) we’re now finally at the point where you can configure
Synapse so that <strong>messages no longer flow through the main process</strong> -
eliminating the bottleneck entirely.  What’s more, the Matrix.org homeserver
has now been successfully running in this config and enjoying the massive
scalability improvements for the last 2 weeks! Huge kudos goes to Erik and the
wider Synapse team for pulling this off.</p>
<p>Some readers might wonder how this ties in with <a href="https://matrix.org/blog/2020/10/08/dendrite-is-entering-beta">Dendrite entering
beta</a>, given one
of Dendrite’s design goals is full horizontal scalability.  The answer is that
we’re very much using Dendrite for experimentation and next-gen stuff at the
moment (currently focused more on scaling downwards for P2P rather than
scaling upwards for megaservers) - while Synapse is the stable and long-term
supported option.</p>
<p>So, that’s the context - now over to Erik with more than you could possibly
ever want to know about how we actually did it...</p>
<h2 id="background">Background</h2>
<p>Synapse started life off back in 2014 as a single monolithic python process,
and for quite a while we made it scale by adding more and more in-memory
caches to speed things up by avoiding hitting the database (at the expense of
RAM).  It looked like this:</p>
<div style="margin: auto; max-width: 640px;">
    <img src="/blog/img/2020-11-03-synapse1.png"/>
</div>
<p>Eventually the caches stopped helping and we needed more than one thread of
execution in order to spread CPU across multiple cores. Python’s Global
Interpreter Lock (<a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>)
means that Python can mainly only use one CPU core at a time, so starting more
threads doesn’t help with scalability - you have to run multiple processes.</p>
<p>Now, the vast majority of the work that Synapse does is related to “streams”.
These are append only sequences of rows, such as the events stream, typing
stream, receipts stream, etc. When a new event arrives (for example) we write
it to the events stream, and then notify anything waiting that there has been
an update. The <code>/sync</code> endpoint, for instance, will wait for updates to streams
and send them down to long-polling Matrix clients. </p>
<p>Streams support being added to concurrently, so have a concept of the
“persisted up-to position”. This is the point where <strong>all</strong> rows before that
point have finished persisting. Readers only read up to the current “persisted
up-to position”, so that they don’t skip updates that haven’t finished
persisting at that point. (E.g. if two events A and B get assigned positions 5
and 6, but B finishes persisting first, then the persisted up to position will
remain at 4 until A finishes persisting and then it jumps to 6).</p>
<p>To split any meaningful amount of work into separate processes, we need to add
a mechanism where processes can be told that updates to streams have happened
(otherwise they’d have to repeatedly poll the DB, which would be deeply
inefficient). The architecture ended up being one where we had the “main”
process that streams updates via a custom replication protocol (initially
long-polling HTTP; later custom TCP) to any number of “worker” processes. This
meant that we could move sync stream handling (and other read apis) off the
main process and onto workers, but also that all database writes had to go
through the single main process (as it was a star topology, the main process
could talk to all workers but workers could only talk to the main process and
not each other).</p>
<p><img src="/blog/img/2020-11-03-synapse2.png" alt="2020-11-03-synapse2.png" /></p>
<p>As an aside: cache invalidations also had to be streamed down the replication
connections, which has the side effect that we could only cache things that
would only be invalidated on the main process.</p>
<p>We continued to move more and more read APIs out onto separate workers. We
also added workers in front of the main process that would e.g. handle the
creation of the new events, authenticating, etc, and then call out to the main
process with the event for it to persist the event.</p>
<h2 id="moving-writes-off-the-main-process">Moving writes off the main process</h2>
<p>Eventually we ran out of stuff to move out of the main process that didn’t
involve writing to the DB. To write stuff from other processes we needed a way
for the workers to stream updates to each other. The easiest and most obvious
way was to just use Redis and its pub/sub support. </p>
<p><img src="/blog/img/2020-11-03-synapse3.png" alt="2020-11-03-synapse3.png" /></p>
<p>This almost allowed us to move writing of a particular stream to a different
worker, <em>except</em> writing to streams generally also meant invalidating caches
which in itself requires writing to a stream. We needed a way of writing to
the cache invalidation stream from multiple workers at once.</p>
<p>Sharding the cache invalidation thankfully turned out to be easy, as workers
would simply call the cache invalidation function whenever they get an
invalidation notice over replication. In particular, the ordering of
invalidations from different workers doesn’t matter and so there isn’t a need
to calculate a single “persisted up-to position”. Sharding then just becomes a
case of adding the name of the worker that is writing the update to the
replication stream, and then workers reading from it can basically treat the
cache stream the same as if they were multiple streams, one per worker.</p>
<p>This then unlocks the ability to move writing of streams off the main process
and onto different workers - and so we added the “event persister” worker for
offloading the main event stream off the main process:</p>
<p><img src="/blog/img/2020-11-03-synapse4.png" alt="2020-11-03-synapse4.png" /></p>
<h2 id="sharding-the-events-stream">Sharding the events stream</h2>
<p>Eventually the worker responsible for doing nothing but persisting events
started maxing out CPU. This meant that we had to look at sharding the events
stream, i.e. writing to it from multiple workers.</p>
<p>This is more complicated than sharding the cache invalidation stream as the
ordering of the events does matter; we send them down sync streams, in order,
with a token that indicates where the sync stream is up to in the events
stream. This means that workers need to be able to calculate a “persisted
up-to position” when getting updates from different workers. </p>
<p>The easiest way of doing that is to simply set the persisted up-to position as
the minimum position received over federation from all active writers. This
works, except events would only be processed after all other writers have
subsequently written events (to advance the persisted position past the point
at which the event was written), which can add a lot of latency depending on
how often events are written. </p>
<p>A refinement is to note that if you have a persisted up-to position of 10,
then receive updates at sequential positions 11, 12, 13 and 14, you know that
everything between 10 and 14 has finished persisting (as you received updates
about them), and so can set the persisted up-to position to 14. Annoyingly,
it’s not required that positions are sequential without gaps (due to various
technical considerations), and so in the worst case this still has the same
problems as the naïve solution.</p>
<p>To avoid these problems we change the persisted up-to position to be a <a href="https://en.wikipedia.org/wiki/Vector_clock">vector
clock</a> of positions; tracking a
vector of positions - one per writer. This still allows answering the query of
“get all events after token X” (as events are written with the position and
the name of the writer). The persisted up-to position is then calculated by
just tracking the last position seen to arrive over replication from each
writer. </p>
<p>This allows writing events from multiple workers, while ensuring that other
workers can correctly keep track of a “persisted up-to position”. Then it's
just a matter of inspecting the code to ensure that it does not assume that it
is the only writer to the stream. In the case of writing to the events stream,
we note that the function persisting events assumes it's the only writer for a
given room, so when sharding we have to ensure that there are no concurrent
writes to the same room. This is most easily done by sharding based on room
ID, and ensuring that the mapping of room ID to worker does not change
(without coordination).</p>
<p>The only thing left is to then encode the vector clock position into the sync
tokens. We want to ensure that these tokens are not too long, as they get
included as query string parameters (e.g. the <code>since=</code> parameter of <code>/sync</code>).
By assigning persistent unique integer IDs to workers the vector clock can be
persisted as a sequence of pairs of integers, which is relatively few bytes so
long as we don’t have too many workers writing to the events stream. We can
further reduce the size of the tokens by calculating an integer “persisted
up-to position” as we did before, encoding that and only including positions
for workers that are larger than the integer persisted upto position. (The
idea here is that most of the time only a small number of workers will be
ahead of the calculated persisted up-to position, and so we only need to
encode those).</p>
<p>And this is what we have today:</p>
<p><img src="/blog/img/2020-11-03-synapse5.png" alt="2020-11-03-synapse5.png" /></p>
<p>The major limitation of the current situation is that you can’t dynamically
add/remove workers which persist events, as the sharding by room ID is
calculated at startup, and so changing it requires restarting the whole
system. This could be replaced by any system that allowed coordination over
which persister is allowed to write to a room at any given point. However this
is likely tricky to get right in practice, but would allow dynamic auto
scaling of deployments, or automatically recovering from a worker that gets
wedged/dies.</p>
<p>Finally, it’s worth noting that sharding event persisters isn’t the only
performance work that’s been going on - switching everything over to python 3
and async twisted has helped, along with lots of smaller optimisations on the
hot paths, and further rebalancing workers (e.g. moving background jobs off
the master process to dedicated workers).  We’ve also benefited a lot from the
maintainability of rolling out mypy typing throughout the codebase.  And next
up, we’ll be going back to speeding up the codebase as a whole - starting with
algorithmic state resolution improvements! 🎉</p>
<h3 id="performance">Performance</h3>
<p>So, how does it stack up?</p>
<p>Here’s the send time heatmap on Matrix.org showing the step change on Oct 16th
when we rolled out the second event persister (full disclosure: this also
coincides with moving background processes off the main Synapse process to a
background worker).  As you can see, we go from messages being spread over a
huge range of durations (up to several seconds) to the sweet spot being 50ms
or less - a spectacular improvement!</p>
<p><img src="/blog/img/2020-11-03-synapse-heatmap.png" alt="2020-11-03-synapse-heatmap.png" /></p>
<p>Meanwhile, here’s the actual CPU utilisation as we split the traffic from a
single event persister (yellow) to two persisters (one yellow, one blue),
showing the sharding beautifully horizontally balancing CPU between the two
active/active worker processes:</p>
<p><img src="/blog/img/2020-11-03-synapse-cpu.png" alt="2020-11-03-synapse-cpu.png" /></p>
<p>We’ve yet to loadtest to see just how fast we can go now (before we start
hitting bottlenecks on the postgres cluster), but it sure feels good to have
all our CPU headroom back on Matrix.org again, ready for the next wave of
users to arrive.</p>
<h3 id="conclusion">Conclusion</h3>
<p>So there you have it: folks running massive homeservers (50K+ concurrent
users) like Matrix.org (and <em>cough</em> various high profile public sector
deployments) are no longer held hostage by the bottleneck of the main synapse
process and should feel free to experiment with setting up event persister
workers to handle high traffic loads.  Otherwise, if you can spread your users
over smaller servers, that’s also a good bet (assuming they don’t have
massively overlapping room membership, like we see on Matrix.org.)</p>
<p>The current <a href="https://github.com/matrix-org/synapse/blob/develop/docs/workers.md">worker
documentation</a>
is up-to-date, although does assume you are already very familiar with how to
administer Synapse.  It’s also very much subject to change, as we keep adding
new workers and improving the architecture.  However, now is a pretty good
time to get involved if you’re interested in large-scale Matrix deployments.</p>
<p>-- The Synapse Team</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;10&#x2F;20&#x2F;dendrite-0-2-0-released&#x2F;" title="Dendrite 0.2.0 released">Dendrite 0.2.0 released</a></h2>
                <span>
                    20.10.2020 19:35
                    —
                    <a href="/category/releases">
                        Releases
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi all,</p>
<p>It's been over a week since our next-generation homeserver <a href="https://matrix.org/blog/2020/10/08/dendrite-is-entering-beta">Dendrite entered
beta</a>, and it's
been a wild rollercoaster ride as the team has been frantically zapping all
the initial teething issues that came up - mostly around room federation
getting 'stuck' due to needing to fix bugs in how room state is managed.  Huge
huge thanks to everyone who has spun up a Dendrite to experiment and report
bugs!</p>
<p>We're now in an impressively better place, and it's feeling way more stable now
(but please don't trust it with your data yet).  So we've skipped 0.1.x and jumped
straight to 0.2.0.</p>
<p>Now would be a great time for more intrepid explorers to try spinning up a
server from https://github.com/matrix-org/dendrite and see how it feels - the
more feedback the better.  And if you got scared off by weird bugs in 0.1.0,
now's the right time to try it again!</p>
<p>Full changelog follows:</p>
<h2 id="dendrite-0-2-0-2020-10-20">Dendrite 0.2.0 (2020-10-20)</h2>
<h3 id="important">Important</h3>
<ul>
<li>This release makes breaking changes for polylith deployments, since they now use the multi-personality binary rather than separate binary files
<ul>
<li>Users of polylith deployments should revise their setups to use the new binary - see the Features section below</li>
</ul>
</li>
<li>This release also makes breaking changes for Docker deployments, as are now publishing images to Docker Hub in separate repositories for monolith and polylith
<ul>
<li>New repositories are as follows: <a href="https://hub.docker.com/repository/docker/matrixdotorg/dendrite-monolith">matrixdotorg/dendrite-monolith</a> and <a href="https://hub.docker.com/repository/docker/matrixdotorg/dendrite-polylith">matrixdotorg/dendrite-polylith</a></li>
<li>The new <code>latest</code> tag will be updated with the latest release, and new versioned tags, e.g. <code>v0.2.0</code>, will preserve specific release versions</li>
<li><a href="https://github.com/matrix-org/dendrite/tree/master/build/docker">Sample Compose configs</a> have been updated - if you are running a Docker deployment, please review the changes</li>
<li>Images for the client API proxy and federation API proxy are no longer provided as they are unsupported - please use <a href="docs/nginx/">nginx</a> (or another reverse proxy) instead</li>
</ul>
</li>
</ul>
<h3 id="features">Features</h3>
<ul>
<li>Dendrite polylith deployments now use a special multi-personality binary, rather than separate binaries
<ul>
<li>This is cleaner, builds faster and simplifies deployment</li>
<li>The first command line argument states the component to run, e.g. <code>./dendrite-polylith-multi roomserver</code></li>
</ul>
</li>
<li>Database migrations are now run at startup</li>
<li>Invalid UTF-8 in requests is now rejected (contributed by <a href="https://github.com/Pestdoktor">Pestdoktor</a>)</li>
<li>Fully read markers are now implemented in the client API (contributed by <a href="https://github.com/Lesterpig">Lesterpig</a>)</li>
<li>Missing auth events are now retrieved from other servers in the room, rather than just the event origin</li>
<li><code>m.room.create</code> events are now validated properly when processing a <code>/send_join</code> response</li>
<li>The roomserver now implements <code>KindOld</code> for handling historic events without them becoming forward extremity candidates, i.e. for backfilled or missing events</li>
</ul>
<h3 id="fixes">Fixes</h3>
<ul>
<li>State resolution v2 performance has been improved dramatically when dealing with large state sets</li>
<li>The roomserver no longer processes outlier events if they are already known</li>
<li>A SQLite locking issue in the previous events updater has been fixed</li>
<li>The client API <code>/state</code> endpoint now correctly returns state after the leave event, if the user has left the room</li>
<li>The client API <code>/createRoom</code> endpoint now sends cumulative state to the roomserver for the initial room events</li>
<li>The federation API <code>/send</code> endpoint now correctly requests the entire room state from the roomserver when needed</li>
<li>Some internal HTTP API paths have been fixed in the user API (contributed by <a href="https://github.com/S7evinK">S7evinK</a>)</li>
<li>A race condition in the rate limiting code resulting in concurrent map writes has been fixed</li>
<li>Each component now correctly starts a consumer/producer connection in monolith mode (when using Kafka)</li>
<li>State resolution is no longer run for single trusted state snapshots that have been verified before</li>
<li>A crash when rolling back the transaction in the latest events updater has been fixed</li>
<li>Typing events are now ignored when the sender domain does not match the origin server</li>
<li>Duplicate redaction entries no longer result in database errors</li>
<li>Recursion has been removed from the code path for retrieving missing events</li>
<li><code>QueryMissingAuthPrevEvents</code> now returns events that have no associated state as if they are missing</li>
<li>Signing key fetchers no longer ignore keys for the local domain, if retrieving a key that is not known in the local config</li>
<li>Federation timeouts have been adjusted so we don't give up on remote requests so quickly</li>
<li><code>create-account</code> no longer relies on the device database (contributed by <a href="https://github.com/ThatNerdyPikachu">ThatNerdyPikachu</a>)</li>
</ul>
<h3 id="known-issues">Known issues</h3>
<ul>
<li>Old events can incorrectly appear in <code>/sync</code> as if they are new when retrieving missing events from federated servers, causing them to appear at the bottom of the timeline in clients</li>
<li>Memory can explode when catching up after a federation outage.</li>
</ul>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;10&#x2F;19&#x2F;combating-abuse-in-matrix-without-backdoors&#x2F;" title="Combating abuse in Matrix - without backdoors.">Combating abuse in Matrix - without backdoors.</a></h2>
                <span>
                    19.10.2020 00:00
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <h3 id="update-nov-9th-2020">UPDATE: Nov 9th 2020</h3>
<p>Not only are UK/US/AU/NZ/CA/IN/JP considering mandating
backdoors, but it turns out that the Council of the European Union is working on it too, having created an advanced
<a href="https://files.orf.at/vietnam2/files/fm4/202045/783284_fh_st12143-re01en20_783284.pdf">Draft Council Resolution on Encryption</a>
as of Nov 6th, which could be approved by the Council as early as Nov 25th if it passes approval.  This doesn't directly
translate into EU legislation, but would set the direction for subsequent EU policy.</p>
<p>Even though the Draft Council Resolution does not explicitly call for backdoors, the language used...</p>
<blockquote>
<p>Competent authorities must be able to access data in a lawful and targeted manner</p>
</blockquote>
<p>...makes it quite clear that they are seeking the ability to break encryption on demand: i.e. a backdoor.</p>
<p>Please help us spread the word that backdoors are fundamentally flawed - read on for the rationale, and an alternative
approach to combatting online abuse.</p>
<hr />
<p>Hi all,</p>
<p>Last Sunday (Oct 11th 2020), the UK Government published an <a href="https://www.gov.uk/government/publications/international-statement-end-to-end-encryption-and-public-safety">international statement on end-to-end encryption and public safety</a>, co-signed by representatives from the US, Australia, New Zealand, Canada, India and Japan.  The statement is well written and well worth a read in full, but the central point is this:</p>
<blockquote>
<p>We call on technology companies to [...] enable law enforcement access to content in a readable and usable format where an authorisation is lawfully issued, is necessary and proportionate, and is subject to strong safeguards and oversight.</p>
</blockquote>
<p>In other words, this is an explicit request from seven of the biggest governments in the world to mandate a backdoor in end-to-end encrypted (E2EE) communication services: a backdoor to which the authorities have a secret key, letting them view communication on demand.  This is big news, and is of direct relevance to Matrix as an end-to-end encrypted communication protocol whose core team is currently centred in the UK.</p>
<p>Now, we sympathise with the authorities’ predicament here: we utterly abhor child abuse, terrorism, fascism and similar - and we did not build Matrix to enable it.  However, trying to mitigate abuse with backdoors is, unfortunately, <strong>fundamentally flawed</strong>.</p>
<ul>
<li>
<p>Backdoors necessarily introduce a fatal weak point into encryption for <em>everyone</em>, which then becomes the ultimate high value target for attackers.  Anyone who can determine the secret needed to break the encryption will gain full access, and you can be absolutely sure <strong><a href="https://techcrunch.com/2016/07/27/security-experts-have-cloned-all-seven-tsa-master-keys/">the backdoor key will leak</a></strong> - whether that’s via intrusion, social engineering, brute-force attacks, or accident.  And even if you unilaterally trust your current government to be responsible with the keys to the backdoor, is it wise to unilaterally trust their successors?  Computer security is only ever a matter of degree, and the only safe way to keep a secret like this safe is for it not to exist in the first place.</p>
</li>
<li>
<p>End-to-end encryption is nowadays a completely ubiquitous technology; <strong>an attempt to legislate against it is like trying to turn back the tide</strong> or declare a branch of mathematics illegal.  Even if Matrix did compromise its encryption, users could easily use any number of other approaches to additionally secure their conversations - from PGP, to OTR, to using one-time pads, to sharing content in password-protected ZIP files.  Or they could just switch to a E2EE chat system operating from a jurisdiction without backdoors.</p>
</li>
<li>
<p>Governments protect their own data using end-to-end encryption, precisely because they do not want other governments being able to snoop on them.  So not only is it hypocritical for governments to argue for backdoors,** it immediately puts their own governmental data at risk of being compromised**.  Moreover, creating infrastructure for backdoors sets an incredibly bad precedent to the rest of the world - where less salubrious governments will inevitably use the same technology to the massive detriment of their citizens’ human rights.</p>
</li>
<li>
<p>Finally, in Matrix’s specific case: Matrix is an encrypted decentralised open network powered by open source software, where anyone can run a server.  Even if the Matrix core team were obligated to add a backdoor, this would be visible to the wider world - and <strong>there would be no way to make the wider network adopt it</strong>.  It would just damage the credibility of the core team, push encryption development to other countries,  and the wider network would move on irrespectively.</p>
</li>
</ul>
<p>In short, we need to keep E2EE as it is so that it benefits the 99.9% of people who are good actors. If we enforce backdoors and undermine it, then the bad 0.1% percent simply will switch to non-backdoored systems while the 99.9% are left vulnerable.</p>
<p>We’re not alone in thinking this either: the GDPR (the world-leading regulation towards data protection and privacy) explicitly calls out robust encryption as a necessary information security measure. In fact, the risk of US governmental backdoors explicitly caused the <a href="http://curia.europa.eu/juris/document/document.jsf?docid=228677&amp;doclang=EN">European Court of Justice to invalidate the Privacy Shield</a> for EU-&gt;US data.  The position of the seven governments here (alongside <a href="https://ec.europa.eu/home-affairs/sites/homeaffairs/files/what-we-do/policies/european-agenda-security/20200724_com-2020-607-commission-communication_en.pdf">recent communications by the EU commissioner</a> on the ‘problem’ of encryption) is a significant step back on the protection of the fundamental right of privacy.</p>
<p>So, how do we solve this predicament for Matrix?</p>
<p>Thankfully: <strong>there is another way.</strong></p>
<p>This statement from the seven governments aims to protect the general public from bad actors, but it clearly undermines the good ones.  What we <em>really</em> need is something that empowers users and administrators to identify and protect themselves from bad actors, without undermining privacy.</p>
<p>What if we had a standard way to let users themselves build up and share their own views of whether other users, messages, rooms, servers etc. are obnoxious or not?  What if you could visualise and choose which filters to apply to your view of Matrix?</p>
<p>Just like the Web, Email or the Internet as a whole, there is literally no way to unilaterally censor or block content in Matrix.  But what we <em>can</em> do is provide first-class infrastructure to let users (and room/community moderators and server admins) make up their own mind about who to trust, and what content to allow.  This would also provide a means for authorities to publish reputation data about illegal content, providing a privacy-respecting mechanism that admins/mods/users can use to keep illegal content away from their servers/clients.</p>
<p>The model we currently have in mind is:</p>
<ul>
<li>Anyone can gather reputation data about Matrix rooms / users / servers / communities / content, and publish it to as wide or narrow an audience as they like - providing their subjective score on whether something in Matrix is positive or negative in a given context.</li>
<li>This reputation data is published in a privacy preserving fashion - i.e. you can look up reputation data if you know the ID being queried, but the data is stored pseudonymised (e.g. indexed by a hashed ID).</li>
<li>Anyone can subscribe to reputation feeds and blend them together in order to inform how they filter their content.  The feeds might be their own data, or from their friends, or from trusted sources (e.g. a fact-checking company).  Their blended feed can be republished as their own.</li>
<li>To prevent users getting trapped in a factional filter bubble of their own devising, we’ll provide UI to visualise and warn about the extent of their filtering - and make it easy and fun to shift their viewpoint as needed.</li>
<li>Admins running servers in particular jurisdictions then have the option to enforce whatever rules they need on their servers (e.g. they might want to subscribe to reputation feeds from a trusted source such as <a href="https://www.iwf.org.uk/">the IWF</a>, identifying child sexual abuse content, and use it to block it from their server).</li>
<li>This isn’t just about combating abuse - but the same system can also be used to empower users to filter out spam, propaganda, unwanted NSFW content, etc on their own terms.</li>
</ul>
<p>This forms a <em>relative</em> reputation system.  As uncomfortable as it may be, one man’s terrorist is another man’s freedom fighter, and different jurisdictions have different laws - and it’s not up to the Matrix.org Foundation to play God and adjudicate.  Each user/moderator/admin should be free to make up their own mind and decide which reputation feeds to align themselves with.  That is not to say that this system would help users locate extreme content - the privacy-preserving nature of the reputation data means that it’s only useful to filter <em>out</em> material which would otherwise already be visible to you - not to locate new content.</p>
<p>In terms of how this interacts with end-to-end-encryption and mitigating abuse: the reality is that the vast majority of abuse in public networks like Matrix, the Web or Email is visible from the public unencrypted domain. Abusive communities generally want to attract/recruit/groom users - and that means providing a public front door, which would be flagged by a reputation system such as the one proposed above.  Meanwhile, communities which are entirely private and entirely encrypted typically still have touch-points with the rest of the world - and even then, the chances are extremely high that they will avoid any hypothetical backdoored servers.  In short, investigating such communities requires traditional infiltration and surveillance by the authorities rather than an ineffective backdoor.</p>
<p>Now, this approach may sound completely sci-fi and implausibly overambitious (our speciality!) - but we’ve actually started successfully building this already, having been refining the idea over the last few years.  <a href="https://github.com/matrix-org/matrix-doc/blob/msc2313/proposals/2313-moderation-policy-rooms.md">MSC2313</a> is a first cut at the idea of publishing and subscribing to reputation data - starting off with simple binary ban rules.  It’s been implemented and in production for over a year now, and is used to maintain shared banlists used by both matrix.org and mozilla.org communities.  The next step is to expand this to support a blendable continuum of reputation data (rather than just binary banlists), make it privacy preserving, and get working on the client UX for configuring and visualising them.</p>
<p>Finally: we are continuing to hire a dedicated Reputation Team to work full time on building this (kindly funded by Element).  This is a major investment in the future of Matrix, and frankly is spending money that we don’t really have - but it’s critical to the long-term success of the project, and perhaps the health of the Internet as a whole.  There’s nothing about a good relative reputation system which is particularly specific to Matrix, after all, and many other folks (decentralised and otherwise) are clearly in desperate need of one too. We are actively looking for funding to support this work, so if you’re feeling rich and philanthropic (or a government wanting to support a more enlightened approach) we would <em>love</em> to hear from you at <a href="mailto:funding@matrix.org">funding@matrix.org</a>!</p>
<p>Here’s to a world where users have excellent tools to protect themselves online - and a world where their safety is not compromised by encryption backdoors.</p>
<p>-- The Matrix.org Core Team</p>
<p>*Comments at <a href="https://news.ycombinator.com/item?id=24826951">HN</a>, <a href="https://lobste.rs/s/ntyvtw/combating_abuse_matrix_without">lobste.rs</a>, and <a href="https://www.reddit.com/r/linux/comments/je8s7x/combating_abuse_in_matrix_without_backdoors/">r/linux</a>, <a href="https://lwn.net/Articles/834710/">LWN</a></p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;10&#x2F;08&#x2F;dendrite-is-entering-beta&#x2F;" title="Dendrite is entering Beta!">Dendrite is entering Beta!</a></h2>
                <span>
                    08.10.2020 00:00
                    —
                    <a href="/category/releases">
                        Releases
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi all,</p>
<p>We’re very excited to announce that Dendrite, the next-generation Matrix homeserver from the core Matrix team, is at last exiting alpha development and entering beta testing!</p>
<p>The path we’ve taken to get here has been quite a curious one, and it’s worth recapping to give context on why it’s taken reality a little while to catch up with the dream. :)</p>
<p>The Dendrite project has its roots in 2016 as <a href="https://github.com/matrix-org/dendron">Dendron</a>: an attempt to write a next-generation homeserver in Golang rather than Python, in order to benefit from Go’s stronger typing, ease of profiling (no twisted stack-shredding via deferredInlineCallbacks), multithreading and faster GC performance.  The idea for Dendron was to do a <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">strangler pattern</a> rewrite of Synapse - where we’d insert Dendron in front of Synapse as a load balancer, and incrementally replace Synapse’s API endpoints with ones implemented by Dendron.</p>
<p>However, as the project started to progress, it became clear that this was going to end up with many of Synapse’s architectural choices being baked into the project - particularly the DB schema and data flow architecture, such that the new endpoints could interoperate with the existing Python ones.  We got as far as putting Dendron live on matrix.org and moving some of the login/registration APIs over to it… but then work fizzled out due to Synapse demanding more urgent attention as traffic grew on Matrix.org, combined with concerns about whether Dendron was the right approach in general.</p>
<p>So, towards the end of 2016 (after the rush to launch <del>Vector</del> <del>Riot</del> Element that summer), we went back to the drawing board to devise Dendrite—“Dendron done right!”—as opposed to Dendron, which in retrospect was Dendrite done wrong. ;) The new vision was:</p>
<ul>
<li>Build a massively horizontally scalable architecture, such that large Matrix deployments like matrix.org and big government deployments could run smoothly without the constant scalability headaches we were seeing at the time with Synapse</li>
<li>Do so by splitting the server into well-defined microservice components, each of which could independently horizontally scale, each with its own DB (if desired)</li>
<li>Connect the components together with a set of append-only logs via <a href="https://kafka.apache.org/">Kafka</a> or similar, easily letting components shard and maintain their databases from the logs, allowing rolling upgrades, possibly schema upgrades, and all sorts of other niceties.  The logs effectively become a primary source of truth rather than putting all the onus on a massive monolithic ever-growing database</li>
</ul>
<p>Rather than Dendron’s top-down approach, instead Dendrite started bottom-up with the very hardest bit: <a href="https://github.com/matrix-org/gomatrixserverlib">gomatrixserverlib</a>, a standalone Go library implementing the state resolution algorithms and performing federation requests (such that it might also someday be used as a general purpose way to add Matrix federation support to an existing Go codebase).</p>
<p>Then we started building out the various components to implement the various services, starting with the roomserver (the service which models the history and state of one or more rooms in the server), then the syncserver (the service which implements the /sync API to let clients receive messages), etc. We even implemented a simplified in-memory version of Kafka named <a href="https://github.com/matrix-org/naffka">naffka</a>—useful for glueing together the microservice components when running them all within a single binary.</p>
<p>Things were looking pretty positive by the summer of 2017: we had the server sending/receiving messages, federating with Synapse, and looking tantalisingly close:</p>
<blockquote>
<p lang="en" dir="ltr">We just sent the first ever synapse-&gt;dendrite federated traffic, including full dendrite media API (thumbnailing, fed, etc)!!! :D :D :D <a href="https://t.co/sBcM2jMAr6">pic.twitter.com/sBcM2jMAr6</a></p>&mdash; Matrix (@matrixdotorg) <a href="https://twitter.com/matrixdotorg/status/872861579141947392?ref_src=twsrc%5Etfw">June 8, 2017</a>
</blockquote>
<p>However, we then hit three fairly major obstacles:</p>
<ul>
<li><a href="https://matrix.org/blog/2017/07/07/a-call-to-arms-supporting-matrix">Matrix lost its funding</a></li>
<li>In the ensuing uncertainty, the two lead developers (Mjark &amp; Kegan) went to work elsewhere</li>
<li>Meanwhile, Matrix uptake was starting to explode and Synapse was failing to scale to handle the traffic on matrix.org (and elsewhere)</li>
</ul>
<p>At first, having formed what would become New Vector (now Element) to keep the rest of the core team hired, we pushed to see if we could get Dendrite finished fast enough to replace Synapse, with Erik &amp; richvdh jumping over from Synapse to pick up the remaining work.  However, it became clear that we urgently needed a quicker solution to address all the overloaded Synapses out there, and so they swung back to focus on improving Synapse (taking inspiration from some of the design of Dendrite - e.g. offloading endpoints onto worker processes connected via replication streams, and using <a href="https://opentracing.io/">OpenTracing</a> to debug traffic as it flows over the various services).</p>
<p>At this point, Dendrite maintenance was in effect valiantly taken over by the community, with Brendan and later Anoa keeping the ball going in 2017, joined by APWhitehat in GSoC 2018 and cnly in GSoC 2019.  The fact that Dendrite is now here today is thanks in no small part to their work to keep the project alive in its “wilderness years” between Sept 2017 and Dec 2019.</p>
<p>Meanwhile, it became clear that we were overdue getting Matrix itself out of beta - and the last thing we wanted to do was to split and dilute the implementation work of Matrix 1.0 over both Synapse and Dendrite - so we consciously made the decision to focus all our effort on Synapse for solving the remaining bugs and challenges.</p>
<p>Then, in July 2019, <a href="https://matrix.org/blog/2019/06/11/introducing-matrix-1-0-and-the-matrix-org-foundation">Matrix and Synapse exited beta</a>, and we finally started to see light at the end of the tunnel.  In October we started dusting off Dendrite again - looking to use it as a relatively simple and flexible codebase for <a href="https://youtu.be/eA0KnTt4O7E?t=1423">experimenting with Peer-to-Peer Matrix</a>, not least because being Go it can compile to WebAssembly and run clientside, and because even though Dendrite was originally built with massive deployments in mind, it turns out the elastic scaling means it can also scale down pretty small too—as a part of the <a href="http://testflight.apple.com/join/Tgh2MEk6">iOS P2P demo</a>, we’ve even ran full Dendrite homeservers on iPhones embedded into Element iOS! :)</p>
<p>In Dec 2019, we finally got to the point where Element could fund full-time dedicated development on Dendrite once again, with Neil Alexander joining the project and focusing fulltime on getting Dendrite out of alpha and getting it working for P2P and embedded usage (adding libp2p as a federation transport, and adding SQLite support) - and in Jan 2020 we got Dendrite <a href="https://archive.fosdem.org/2020/schedule/event/dip_p2p_matrix/">successfully running clientside in a WASM service worker</a> (just in time for FOSDEM!). Then, in Feb 2020, Kegan returned to the project to work fulltime on Dendrite - and the race began in earnest to get Dendrite ready for beta!</p>
<p>Here’s a pretty picture courtesy of GitHub to visualise the progress:</p>
<p><img src="/blog/img/2020-10-08-dendrite-contributors.png" alt="020-10-08-dendrite-contributors.png" /></p>
<p>Throughout 2020 there’s been a huge amount of stabilisation work and polish:</p>
<ul>
<li>Refactoring much of Dendrite’s foundation to make the codebase more maintainable</li>
<li>Created all-new user server, key server, signing key server microservices</li>
<li>Moving some work from existing microservices (ultimately superseding the former currentstateserver, publicroomsapi and typingserver microservices altogether)</li>
<li>Developing new testing infrastructure:
<ul>
<li><a href="https://github.com/matrix-org/complement">Complement</a> - our brand new Golang Matrix integration test harness</li>
<li><a href="https://github.com/matrix-org/dendrite/blob/master/are-we-synapse-yet.py">Are We Synapse Yet</a> - an aggregator which parses sytest/complement output to compare how close Dendrite is to passing</li>
</ul>
</li>
<li>All the Matrix 1.0 work - particularly state res v2 &amp; room version support</li>
<li>Making it work with more P2P transports for <a href="https://matrix.org/blog/2020/06/02/introducing-p-2-p-matrix/">all the exciting P2P experiments</a></li>
<li>Supporting backfill and fetching missing events</li>
<li>Fixing up SQLite support to make it work as a first class citizen (with shared storage code where we can!)</li>
<li>Supporting both sending and rejecting invites (even over federation)</li>
<li>E2E encryption support (one-time keys, device lists, send-to-device support)</li>
<li>Improved federation sender logic (resend retries, backoffs, blacklisting, metrics, resetting backoffs when receiving transactions)</li>
<li>Handling both inbound and outbound redactions</li>
<li>User interactive authentication (and implemented on various ‘sudo’ endpoints e.g. deleting devices and changing passwords)</li>
<li>Respecting server ACLs</li>
<li>Rejecting / soft-failing events properly</li>
<li>Support for database schema upgrades</li>
</ul>
<p>... which brings us at last to the present day (Oct 2020), as we declare Dendrite sufficiently stable that we consider it ready for beta testing!</p>
<p>In practice, this means **Dendrite is now ready for experimentation by adventurous Matrix sysadmins. It is <em>NOT</em> ready for production usage yet, but we need folks to test it and help us iron out the remaining bugs!  **Please do not trust it with sensitive data yet, and we don’t recommend trying to run it at scale yet as we haven’t done any serious optimisation work yet.</p>
<p>That said, we do provide the following guarantees:</p>
<ul>
<li>We’re providing versioned releases from here on in, beginning with <a href="https://github.com/matrix-org/dendrite/releases/tag/v0.1.0">0.1.0</a></li>
<li>We don’t expect any major breaking changes to the config or architecture before 1.0</li>
<li>Ready for early adopters to try running Dendrite without experiencing ~daily breaking churn</li>
<li>The database schema is now stable and will upgrade itself going forwards - your database should now be here to stay! (assuming we don’t hit any nasty data loss bugs during beta)</li>
</ul>
<p>In terms of comparison with Synapse, the main things you should get excited about are:</p>
<ul>
<li>Dendrite aims to provide an <strong>efficient</strong>, <strong>reliable</strong> and <strong>scalable</strong> alternative to Synapse:
<ul>
<li>Efficient: A small memory footprint with better baseline performance than an out-of-the-box Synapse</li>
<li>Reliable: Implements the Matrix specification as written, using the <a href="https://github.com/matrix-org/sytest">same test suite</a> as Synapse as well as a <a href="https://github.com/matrix-org/complement">brand new Go test suite</a></li>
<li>Scalable: can run on multiple machines and eventually scale to massive homeserver deployments</li>
</ul>
</li>
<li>This means significantly less memory usage than Synapse (depends on joined rooms, often between 50MB - 400MB resident memory) - although we haven’t tuned this at all yet!</li>
<li>All-new database model, where every microservice instance has its own database tables, letting them scale arbitrarily wide</li>
<li>The ability to efficiently use all your available CPU cores without needing to split into separate processes, thanks to Go and our extensive use of goroutines.  No more Python global interpreter lock! :)</li>
<li>Future experimental MSCs are likely to land in Dendrite before Synapse (e.g <a href="https://github.com/matrix-org/matrix-doc/blob/matthew/msc2753/proposals/2753-peeking-via-sync-v2.md">MSC2753 Peeking via /sync</a> and <a href="https://github.com/matrix-org/matrix-doc/blob/matthew/msc2444/proposals/2444-peeking-over-federation-peek-api.md">MSC2444 Peeking over Federation</a> are already being prototyped (<a href="https://github.com/matrix-org/dendrite/pull/1370">#1370</a> and <a href="https://github.com/matrix-org/dendrite/pull/1391">#1391</a>) in Dendrite rather than Synapse!)</li>
</ul>
<p>The provisos you should know about however are:</p>
<ul>
<li>We’re not feature complete yet: sytest reports 56% CS API coverage and 77% Federation coverage. <strong>NB: these are always going to be underestimates of how much Dendrite actually performs due to how the tests are spread out, in actuality it’s likely more 70% CS, 95% Fed.</strong></li>
<li>No read receipts, membership lazy-loading, presence, push notifications, search, event context, key backups, cross-signing. See changelog for full limitations.</li>
<li>Not battle-tested in the wild by many people (there are probably only ~10 dendrites on the open network today!) - so there’s likely to be a broad spectrum of bugs at first.</li>
<li>Clients that require more exotic features, like lazy loading, may not behave properly yet</li>
<li>Please <strong>use Postgres rather than SQLite wherever possible</strong>—it’s faster and has fewer issues regarding concurrency (some requests on SQLite Dendrites may 500 with ‘database is locked’ - though we’ve worked hard to eliminate most of these)</li>
<li>Dendrite can run in either “monolith” or “polylith” mode. In monolith, all the microservices are linked into a single binary - and <strong>we recommend running in this configuration wherever possible</strong> for now. Monolith mode is <em>extremely</em> capable as it is and has fewer moving parts for things to go wrong and will be the right choice for the majority of beta deployments!</li>
<li>Whilst Dendrite is nearly 100% federation compatible, there may still be situations where it will split-brain and disagree with the current room state that Synapse has calculated. We expect these issues to resolve as we get more user feedback.</li>
</ul>
<p>Architecture-wise, this is what Dendrite looks like under the hood today:</p>
<p><img src="/blog/img/2020-10-08-dendrite-arch.svg" alt="2020-10-08-dendrite-arch.svg" /></p>
<p>To get up and running, please install Go and head on over to the Get Started guide at <a href="https://github.com/matrix-org/dendrite#get-started">https://github.com/matrix-org/dendrite#get-started</a> to join the fun :)</p>
<p>In terms of where we’re going next:</p>
<ul>
<li>Read receipts. It’s a major missing feature and impacts UX significantly.</li>
<li>100% Federation coverage (according to sytest). It’s crucial that Dendrite instances play nicely with other servers. This will be the best metric we have for asserting that we are just as capable as Synapse at the fed level.</li>
<li>Optimisation—<strong>Dendrite has not been optimised yet for speed or resource utilisation!</strong>
<ul>
<li>We plan to add benchmarks which will stress test different microservices in the presence of many different scaling factors (number of users, number of rooms, size of room, number of devices per user, number of sync requests, etc). This will hopefully allow us to identify early on bottlenecks and slow algorithms</li>
<li>Good old fashioned pprof with known slow scenarios to see what’s consuming CPU/memory and fixing issues ad-hoc (which we’ve already done a bit of pre-beta). This may involve adding additional in-memory caches, with a healthy respect for the complexities it may introduce (which Synapse has been bitten by)</li>
</ul>
</li>
<li>We plan to add first class feature flag support for experimental MSCs—experimentation is one thing which makes Dendrite notably different from Synapse, and supporting it more thoroughly going forwards will be important. This may mean adding additional hooks; potentially a dedicated microservice to cleanly separate experiments, we don’t know yet</li>
<li>P2P work will continue with vigour now we have a working, featureful, and relatively stable HS to embed and play with</li>
</ul>
<p>Longer term, it’s pretty hard to say right now when we expect to exit beta (it took Synapse 5 years to exit beta, after all ;) - but obviously we’ll need Dendrite to have parity with Synapse and have no known serious bugs.</p>
<p>Finally: you’re probably wondering what this means for Synapse.  Synapse is here to stay - with tens of thousands of deployments around the world serving tens of millions of users.  The majority of the core team is still focused on improving and optimising Synapse, and we’ll be keeping improving it for the foreseeable.</p>
<p>However, we’ll certainly be experimenting with new stuff on Dendrite first - whether that’s P2P, portable accounts, new-style communities, peeking etc.  We expect Synapse to be the stable long-term-supported solution, while Dendrite (particularly while in beta) will be the more unstable and experimental platform. In the longer term we’ll provide ways of migrating from Synapse to Dendrite however (probably via portable accounts), and perhaps in future new deployments may choose to use Dendrite - a bit like you might choose to use nginx rather than Apache for a new web server these days. But this will be a long transition—meanwhile we expect to see more and more next-generation homeservers like <a href="http://conduit.rs/">Conduit</a>, <a href="https://gitlab.com/mascarene/mascarene">Mascarene</a> or <a href="https://github.com/matrix-construct/construct">Construct</a> coming of age too.</p>
<p>So, there you have it. If you’re an intrepid sysadmin please spin up a Dendrite and start filing bugs! :)</p>
<p>— Matthew, Neil Alexander, Kegan and the whole Matrix team.</p>
<p>Here’s the official changelog:</p>
<h3 id="client-server-api-features">Client-Server API Features</h3>
<h4 id="account-registration-and-management">Account registration and management</h4>
<ul>
<li>Registration: By password only.</li>
<li>Login: By password only. No fallback.</li>
<li>Logout: Yes.</li>
<li>Change password: Yes.</li>
<li>Link email/msisdn to account: No.</li>
<li>Deactivate account: Yes.</li>
<li>Check if username is available: Yes.</li>
<li>Account data: Yes.</li>
<li>OpenID: No.</li>
</ul>
<h4 id="rooms">Rooms</h4>
<ul>
<li>Room creation: Yes, including presets.</li>
<li>Joining rooms: Yes, including by alias or <code>?server_name=</code>.</li>
<li>Event sending: Yes, including transaction IDs.</li>
<li>Aliases: Yes.</li>
<li>Published room directory: Yes.</li>
<li>Kicking users: Yes.</li>
<li>Banning users: Yes.</li>
<li>Inviting users: Yes, but not third-party invites.</li>
<li>Forgetting rooms: No.</li>
<li>Room versions: All (v1 - v6)</li>
<li>Tagging: Yes.</li>
</ul>
<h4 id="user-management">User management</h4>
<ul>
<li>User directory: Basic support.</li>
<li>Ignoring users: No.</li>
<li>Groups/Communities: No.</li>
</ul>
<h4 id="device-management">Device management</h4>
<ul>
<li>Creating devices: Yes.</li>
<li>Deleting devices: Yes.</li>
<li>Send-to-device messaging: Yes.</li>
</ul>
<h4 id="sync">Sync</h4>
<ul>
<li>Filters: Timeline limit only. Rest unimplemented.</li>
<li>Deprecated <code>/events</code> and <code>/initialSync</code>: No.</li>
</ul>
<h4 id="room-events">Room events</h4>
<ul>
<li>Typing: Yes.</li>
<li>Receipts: No.</li>
<li>Read Markers: No.</li>
<li>Presence: No.</li>
<li>Content repository (attachments): Yes.</li>
<li>History visibility: No, defaults to <code>joined</code>.</li>
<li>Push notifications: No.</li>
<li>Event context: No.</li>
<li>Reporting content: No.</li>
</ul>
<h4 id="end-to-end-encryption">End-to-End Encryption</h4>
<ul>
<li>Uploading device keys: Yes.</li>
<li>Downloading device keys: Yes.</li>
<li>Claiming one-time keys: Yes.</li>
<li>Querying key changes: Yes.</li>
<li>Cross-Signing: No.</li>
</ul>
<h4 id="misc">Misc</h4>
<ul>
<li>Server-side search: No.</li>
<li>Guest access: Partial.</li>
<li>Room previews: No, partial support for Peeking via MSC2753.</li>
<li>Third-Party networks: No.</li>
<li>Server notices: No.</li>
<li>Policy lists: No.</li>
</ul>
<h3 id="federation-features">Federation Features</h3>
<ul>
<li>Querying keys (incl. notary): Yes.</li>
<li>Server ACLs: Yes.</li>
<li>Sending transactions: Yes.</li>
<li>Joining rooms: Yes.</li>
<li>Inviting to rooms: Yes, but not third-party invites.</li>
<li>Leaving rooms: Yes.</li>
<li>Content repository: Yes.</li>
<li>Backfilling / get_missing_events: Yes.</li>
<li>Retrieving state of the room (<code>/state</code> and <code>/state_ids</code>): Yes.</li>
<li>Public rooms: Yes.</li>
<li>Querying profile data: Yes.</li>
<li>Device management: Yes.</li>
<li>Send-to-Device messaging: Yes.</li>
<li>Querying/Claiming E2E Keys: Yes.</li>
<li>Typing: Yes.</li>
<li>Presence: No.</li>
<li>Receipts: No.</li>
<li>OpenID: No.</li>
</ul>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;09&#x2F;30&#x2F;welcoming-gitter-to-matrix&#x2F;" title="Welcoming Gitter to Matrix!">Welcoming Gitter to Matrix!</a></h2>
                <span>
                    30.09.2020 16:28
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                <br>
                <small>Last update: 30.09.2020 14:58</small>
            </header>
            <div>
                
                <p><img src="/blog/img/2020-09-30-gitter.png" alt="Gitter ♥️ Matrix" /></p>
<p>Hi all,</p>
<p>We are ridiculously excited to announce that <a href="https://gitter.im">Gitter</a> is joining the Matrix ecosystem and will become the first major existing chat platform to switch to natively speaking Matrix!</p>
<p>If you’re reading this from the Gitter community and have no idea what Matrix is: we’re an open source project that provides an open protocol for secure, decentralised communication - effectively the missing real-time communication layer of the open Web.  The open Matrix network has more than 20M users on it and is growing fast (adding another 1.7M or so with the arrival of Gitter!)</p>
<p>Gitter is easily one of the best developer community chat systems out there, used by the communities of some massive projects (<a href="https://gitter.im/nodejs/home">Node</a>, <a href="https://gitter.im/Microsoft/TypeScript">TypeScript</a>, <a href="https://gitter.im/angular/home">Angular</a>, <a href="https://gitter.im/scala/home">Scala</a> etc) and is a custodian of huge archives of knowledge via their chat logs. Gitter is unique in specifically focusing on developers: their tagline is literally “Where developers come to talk” (unlike Slack, which has barely any community features - or Discord, with its ban on unofficial clients, where developers are a bit of an afterthought relative to the gamers). With Gitter natively joining Matrix, we’re super excited to see the global developer community converging on the open Matrix network - and Gitter’s community rooms should see a huge new lease of life as they’re properly made natively available to the wider network as first class citizens :)</p>
<p>We’ve always had a bit of a crush on Gitter ever since we ended up opposite each other in the exhibition hall at TechCrunch Disrupt Europe 2014 - particularly when they demoed us not only their sexy webapp but also their official IRC server bridge at irc.gitter.im :D  Over the years we’ve been gently nudging them to consider fully embracing Matrix, but perhaps understandably they’ve been busy focusing on their own stuff. However, earlier this year, our friends at GitLab (who acquired Gitter in 2017) reached out to explore the opportunity of Gitter becoming a core part of Matrix rather than a non-core project at GitLab… and we’ve jumped on that opportunity to bring Gitter fully into Matrix.</p>
<p>In practice, the way this is happening is that Element (the company founded by the Matrix core team to fund Matrix development) is acquiring Gitter from GitLab, with a combined Gitter and Element dev team focusing on giving Gitter a new life in Matrix!  You can read about it from the Element angle over on <a href="https://element.io/blog/gitter-is-joining-element/">the Element blog</a>.</p>
<p>Practically speaking, we have a pretty interesting plan here, which we’d like to be very transparent about given it’s a little unusual:</p>
<p>At first, Gitter will keep running as it always has - needless to say, we will be doing everything we can to delight the Gitter community and keep the service in good shape.</p>
<p>Then we’re going to build out native Matrix connectivity - running a dedicated Matrix homeserver on gitter.im with a new bridge direct into the heart of Gitter; letting all Gitter rooms be available to Matrix directly as (say) #angular_angular:gitter.im, and bridging all the historical conversations into Matrix via <a href="https://github.com/matrix-org/matrix-doc/blob/matthew/msc2716/proposals/2716-importing-history-into-existing-rooms.md">MSC2716</a> or similar. We will of course do this entirely as open source, just as Gitter itself is open source thanks to GitLab releasing it under the MIT license in 2017. The plan is to comprehensively document our progress as the flagship worked example case study of “how do you make an existing chat system talk Matrix.”</p>
<p>This will of course replace the old and creaky <a href="https://github.com/matrix-org/matrix-appservice-gitter">matrix-appservice-gitter</a> bridge we’ve been running since 2016. Gitter users will also be able to talk to other users elsewhere in the open Matrix network - e.g. DMing them, and (possibly) joining arbitrary Matrix rooms. Effectively, <strong>Gitter will have become a Matrix client</strong>.</p>
<p>Now we come to the interesting bit. Gitter has some <em>really</em> nice features which are sorely lacking in Element today:</p>
<ul>
<li>Instant live room peeking (less than a second to load the webapp into a live-view of a massive room with 20K users!!)</li>
<li>Seamless onboarding thanks to using GitLab &amp; GitHub for accounts</li>
<li>Curated hierarchical room directory</li>
<li>Magical creation of rooms on demand for every GitLab and GitHub project ever</li>
<li>GitLab/GitHub activity as a first-class citizen in a room’s side-panel</li>
<li>Excellent search-engine-friendly static content and archives</li>
<li>KaTeX support for Maths communities</li>
<li>Threads!</li>
</ul>
<p>...and we promise to do everything in our power to preserve and honour these features at all costs and continue to give the Gitter community the experience they’ve come to know and love.</p>
<p><strong>However</strong>: in the medium/long term, it’s simply not going to be efficient for the combined Element/Gitter team to split our efforts maintaining two high-profile Matrix clients. Our plan is instead to merge Gitter’s features into Element (or next generations of Element) itself and then - if and only if Element has achieved parity with Gitter based on the above list - we expect to upgrade the deployment on gitter.im to a Gitter-customised version of Element. The inevitable side-effect is that we’ll be adding new features to Element rather than Gitter going forwards.</p>
<p>In practice, the main outcome in the end should be Element having benefited massively from levelling up with Gitter - and Gitter benefiting massively from all the goodies which Element and Matrix brings, including:</p>
<ul>
<li>E2E Encryption</li>
<li>Reactions</li>
<li>Constantly improving native iOS &amp; Android clients (which should be a welcome alternative to Gitter’s natives ones, which are <a href="https://gitlab.com/gitlab-org/gitter/webapp/-/issues/2281">already being deprecated</a>)</li>
<li>VoIP and conferencing</li>
<li>All the alternative clients, bots, bridges and servers in Matrix</li>
<li>The full open standard Matrix API</li>
<li>Widgets (embedding webapps into rooms!)</li>
<li>...and of course participation in the wider decentralised Matrix network.</li>
</ul>
<p>So, there you have it. It’s a new era for Gitter - and we look forward to reinvigorating Gitter’s communities over the coming months. We hope Gitter users will be blown away by the features arriving from Matrix… and we hope that Element users will be ecstatic with the performance and polish work that Gitter-parity will drive us towards. Imagine having guest access in Element that can launch and load a massive room in less than a second!</p>
<p>Finally, we would like to explicitly reassure the Gitter community again that we love and understand Gitter (it was one of the very first ever bridges we wrote for Matrix, for instance) - and we will be doing everything we can to not screw up our responsibility in looking after it. Please, please let us know if you have any concerns or if we ever fall short on this.</p>
<p>Any questions, come talk to us on <a href="https://matrix.to/#/#gitter:matrix.org">#gitter:matrix.org</a> - which is bridged with <a href="https://gitter.im/matrix-org/gitter">https://gitter.im/matrix-org/gitter</a>.  Exciting times ahead!</p>
<p>- Matthew, Amandine, and the whole Matrix, Element and Gitter teams.</p>
<div style="text-align: center">
    <img src="/blog/img/2020-09-30-gitter-photo.jpg" width="480" alt="Matthew & Amandine being dorky"/>
    <br/>
    <i><small>Matthew and Amandine model 2014-vintage Matrix & Gitter swag in celebration :D</small></i>
</div>
<h2 id="bonus-update-the-changelog-interview">Bonus update - The Changelog Interview!</h2>
<p>Sid Sijbrandij (CEO at GitLab) and Matthew had a chance to sit down with <a href="https://changelog.com">The Changelog</a> to talk about Gitter's Big Adventure - so tune in to hear the story first hand!  Warning: contains non-ironic use of the word &quot;synergy&quot; :D</p>
<br/>
<div style="text-align: center">
<a rel="noopener" href="https://cdn.changelog.com/uploads/podcast/414/the-changelog-414.mp3">
    <img src="https://matrix.org/blog/img/2020-09-30-gitter-changelog.png" alt="Changelog podcast 414"/>
</a>
<p><a href="https://changelog.com/podcast/414">The Changelog 414: Gitter's Big Adventure</a> - Listen on <a href="https://changelog.com/">Changelog.com</a></p>
</div>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;06&#x2F;16&#x2F;matrix-decomposition-an-independent-academic-analysis-of-matrix-state-resolution&#x2F;" title="Matrix Decomposition: an independent academic analysis of Matrix State Resolution">Matrix Decomposition: an independent academic analysis of Matrix State Resolution</a></h2>
                <span>
                    16.06.2020 20:15
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                <br>
                <small>Last update: 16.06.2020 19:09</small>
            </header>
            <div>
                
                <p>Hi all,</p>
<p>Regular readers of <a href="https://matrix.org/blog/category/this-week-in-matrix/">TWIM</a> may be familiar with the <a href="https://dsn.tm.kit.edu/english/index.php">Decentralized Systems and Network Services Research Group</a> at Karlsruhe Institute of Technology, who have been busy over the last few years analysing Matrix from an independent academic point of view.  The work started in 2018 with Florian Jacob’s <a href="https://dsn.tm.kit.edu/matrix/traveller/explained.html">DSN Traveler</a> spidering project, resulting in the <a href="https://publikationen.bibliothek.kit.edu/1000100364">Glimpse of the Matrix</a> paper analysing Matrix’s scale and room/server distribution (at least as it was back then).</p>
<p>Last week, they released an entirely new paper: <a href="https://dl.acm.org/doi/10.1145/3381991.3395399">Matrix Decomposition: Analysis of an Access Control Approach on Transaction-based DAGs without Finality</a> by Florian Jacob, Luca Becker, Jan Grashöfer and Hannes Hartenstein, presented at <a href="https://www.sacmat.org/2020/index.php">ACM SACMAT ‘20</a>.</p>
<p>Now, the new paper is an absolutely fascinating deep dive analysis into <a href="https://github.com/matrix-org/matrix-doc/blob/master/proposals/1442-state-resolution.md">State Resolution v2</a> - the algorithm at the heart of Matrix which defines how servers merge together their potentially conflicting copies of a given room, such that everyone ends up eventually with a consistent view… even in the face of bad actors. This means that Matrix effectively implements a decentralised access control system - ensuring that users stay banned, and only users with permission can ban, etc.  You can see the <a href="https://matrix.org/blog/img/SACMAT_2020_Talk_Matrix_Decomposition.pdf">slides</a> below, and read the <a href="https://dl.acm.org/doi/pdf/10.1145/3381991.3395399">full paper</a> here. The video of Florian’s talk from SACMAT should be published shortly.</p>
<br/>
<p><object data="https://matrix.org/blog/img/SACMAT_2020_Talk_Matrix_Decomposition.pdf" type="application/pdf" width="1024" height="768"></object></p>
<br/>
<p>To give some context from the Matrix side: designing and implementing State Resolution v2 back in 2018 was a bit of a mission. Our original v1 implementation had some bugs which meant that the result of the merge could unexpectedly favour historical state over the current state (so called ‘state resets’) - thus giving an attacker a way to maliciously revert the state of the room.  In v2 we thought much more carefully about the algorithm, considering state present in one version of the room but not the other as a conflict, separating and applying access control events from regular events, and adding additional ordering of the state in the room by considering events in the context of their authorisation chain (the ‘auth DAG’).  The end result is that we feel confident in v2 State Res, and we haven’t seen any problems with it in the wild since we shipped it in July 2018.</p>
<p>However: state resolution is not intuitive at first - for instance, when you merge two versions of a room together, you treat the state events as unordered sets… even though they are ordered in the context of the room DAG.  The reason is that state res needs to work even if you don’t have a copy of the whole room DAG (otherwise you’d have to download way too much data to participate in a large room).  Another example is the sequence in which orderings are then applied to the state events - and how that interacts with re-authorising those events, to stop malicious ones creeping in.  In the core team, we’ve end up describing it several different ways to try to help folks understand: first Erik’s original <a href="https://github.com/matrix-org/matrix-doc/blob/erikj/state_res_msc/proposals/1442-state-resolution.md">MSC1442</a>, then uhoreg’s <a href="https://matrix.uhoreg.ca/stateres/reloaded.html">literary Haskell implementation</a>, then the terse reference version in <a href="https://matrix.org/docs/spec/rooms/v2">the Spec</a> itself, and most recently Neil Alexander’s <a href="https://matrix.org/docs/guides/implementing-stateres">State Resolution v2 for the Hopelessly Unmathematical</a>.</p>
<p>As a result we are <strong>very</strong> excited and happy that Florian and the DSN team have now published the first ever independent in-depth analysis of the algorithm, particularly in the context of decentralised access control (i.e. enforcing bans, power levels, etc).  We’re pleasantly surprised that apparently “To the best of our knowledge, Matrix is the only system that implements access control based on an eventually consistent partial order without finality and without a consensus algorithm”.</p>
<p>Even better, the DSN team found some remaining thinkos in Synapse’s implementation and the Matrix specification, which could have caused resolution results to diverge from other implementations, specifically:</p>
<ol>
<li>we weren’t enforcing integers in JSON to be within range [-2<sup>53</sup>+1, 2<sup>53</sup>-1], fixed in <a href="https://github.com/matrix-org/synapse/pull/7381">https://github.com/matrix-org/synapse/pull/7381</a> and <a href="https://github.com/matrix-org/matrix-doc/blob/clokep/json-validation-room-ver/proposals/2540-stricter-event-validation.md">MSC2540</a></li>
<li>we forgot to include the notification field when authing power level events, fixed in  <a href="https://github.com/matrix-org/synapse/issues/7501">https://github.com/matrix-org/synapse/issues/7501</a> and <a href="https://github.com/lucavb/matrix-doc/blob/master/proposals/2209-auth-rules-other-keys-in-m.room.power.levels.md">MSC2209</a> (thanks to Luca from DSN for the MSC!)</li>
<li>we forgot to spec the limit that one should apply to the number of parents of an event in the DAG (fixed in <a href="https://github.com/matrix-org/matrix-doc/pull/2538">https://github.com/matrix-org/matrix-doc/pull/2538</a>)</li>
<li>we missed that moderators could set server ACLs which could let them undermine room admins (fixed in <a href="https://github.com/matrix-org/synapse/pull/6834">https://github.com/matrix-org/synapse/pull/6834</a>).</li>
</ol>
<p>All of these have now been fixed in Synapse and the latest versions of the spec (room v6), and we’d like to sincerely thank Florian and Luca for rapidly and responsibly disclosing the issues to us.  In other words: this research is directly improving Matrix, and it’s even more exciting that the stated future work for the DSN team is to work on a <a href="https://en.wikipedia.org/wiki/Formal_verification">formal verification</a> for the security of Matrix’s authorisation rules and state resolution.  This stuff is tough, as anyone who’s played with <a href="https://en.wikipedia.org/wiki/TLA%2B">TLA<sup>+</sup></a> will know, and we are incredibly glad that the research community is helping out to formalise and hopefully prove that State Res v2 is as good as we think it is.</p>
<p>We should stress that DSN’s work is completely independent of The Matrix.org Foundation or anyone else building on the protocol; we’re just writing about it here because we think it’s incredibly cool and deserves the attention of the whole Matrix ecosystem.</p>
<p>Thanks again to Florian and the team - we look forward to seeing what comes next!</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="&#x2F;blog&#x2F;2020&#x2F;06&#x2F;02&#x2F;introducing-p2p-matrix&#x2F;" title="Introducing P2P Matrix">Introducing P2P Matrix</a></h2>
                <span>
                    02.06.2020 00:00
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/matthew-hodgson">
                        Matthew Hodgson
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>TL;DR: we shipped a major update (v0.1.1) to <a href="https://p2p.riot.im">https://p2p.riot.im</a> - fire up a desktop Chrome or Firefox in not-private-browsing mode and give it a go!</p>
<p>Hi folks,</p>
<p>As many know by now, a few of us have been working away since mid-December on experimenting with running Matrix in a peer-to-peer architecture - one where every user has absolute total autonomy and ownership of their conversations, because the only place their conversations exist is on the devices they own.</p>
<p>In some ways this is the logical end goal of Matrix: our aim has always been to empower users to have full control over their communication rather than being beholden to any given service provider, and in a P2P world we completely return power over secure communication to the people.</p>
<h3 id="why-p2p">Why P2P?</h3>
<p>P2P Matrix is about more than just letting users store their own conversations: it can also avoid dependencies on the Internet itself by working over local networks, mesh networks, or situations where the Internet has been cut off.  Even more interestingly, without homeservers, there is nowhere for metadata to accumulate about who is talking to who, and when - which is a legitimate complaint about today’s Matrix network, given the homeservers of all users in a given conversation necessarily have to store that conversation’s metadata.  P2P also lets us radically simplify signup for new users if they don’t have to pick a server to get going - and we avoid the unintentional centralisation of users piling onto public servers.</p>
<p>P2P also forces us to solve many of the hardest remaining problems in Matrix: e.g multi-homed accounts, given multi-device P2P requires your account to exist in multiple places. This in turn unlocks high availability and geo-redundancy for accounts on today’s Matrix network (imagine having a primary and backup homeserver that magically did the right thing!), as well as account portability, and thus also vhosting and load-balancing accounts between servers, and even improved GDPR compliance (for if your user IDs are ephemeral they are no longer personally identifying information baked into your Matrix rooms).  We’ll also need better safety mechanisms to avoid folks exploiting the anonymous nature of the network for abuse, accelerating the work we’re already doing for today’s Matrix network.</p>
<p>The way we’ve been approaching P2P is the “<a href="https://twitter.com/Lucid00/status/1263974339294175232">hamfisted but genius</a>” approach of taking homeservers and running them on the client, alongside or within your Matrix client - meaning that there are literally <strong>no</strong> changes required for any Matrix client to talk P2P Matrix, and so P2P Matrix can instantly benefit from all the work which has gone into Riot and other apps.  As a result, P2P is also a huge motivator towards developing much smaller homeservers which can run efficiently clientside (e.g. Dendrite!) - which is of course great news for Matrix as a whole.  It also forces us to develop more scalable routing algorithms (as you don’t want your client to have to talk to every other device in a room every time it sends a message!) and also spurs development of low bandwidth Matrix transports (as you don’t want the additional chatter of talking to multiple peers to consume all your bandwidth).  Finally, it forces us to really ruggedize federation, given nodes are constantly appearing and disappearing, giving the federation much more of a stress test than we see with today’s relatively static homeservers.</p>
<h3 id="p2p-in-practice">P2P in Practice</h3>
<p>So, P2P has been acting as fuel for a lot of our longer term Matrix work over the last few months.  There have been three main experiments so far: at <a href="https://fosdem.org/2020/schedule/event/dip_p2p_matrix/">FOSDEM</a> we showed off running our next-gen Dendrite homeserver running clientside using HTTP over <a href="https://libp2p.io/">libp2p</a> as the transport.  We also highlighted Timothée Floure’s <a href="https://www.epfl.ch/labs/dedis/wp-content/uploads/2020/01/presentation-2019-2-Timothee-Floure-Experimenting-with-Matrix-federation-over-Yggdrasil.pdf">project at EPFL</a> experimenting with Synapse talking P2P CoAP over yggdrasil as the transport via a proxy.</p>
<p>Most recently, however, we’ve been experimenting with compiling Dendrite down to Web Assembly and running it embedded in Riot Web as a Service Worker, using HTTP over libp2p’s websocket transport (coordinated via a websocket rendezvous server).  Architecturally, it looks like this:</p>
<p><img src="/blog/img/p2p-diag.png" alt="P2P Architecture Diagram" /></p>
<p>Today, we’re shipping a major new alpha (v0.1.1) of this P2P demo up at <a href="https://p2p.riot.im">https://p2p.riot.im</a> (requires desktop Chrome or Firefox in non-private-browsing mode) - which hopefully should give a really usable and concrete taste of the shape of things to come.</p>
<p>The main features are:</p>
<ul>
<li>Your conversations are now persisted in your browser storage (via IndexedDB), meaning that as long as all the browsers participating in a given conversation don’t clear their local storage, rooms on the P2P network are here to stay!</li>
<li>Your room directory lists all the aliases for all the rooms published by active nodes on the network.  Moreover, we now automatically publish a local room alias whenever you join a public room, so that others will be able to discover that room via you, even if the server who originally created the alias has disappeared.</li>
<li>Lots and lots of federation improvements between the nodes - for instance, when a node comes online, others should now automatically detect and send scrollback to it.  Invites should work, and there should no longer be any unexpectedly redacted messages.</li>
</ul>
<p>Needless to say, all the code for this is open source under the Apache license, and if you’re feeling particularly adventurous you can embed your very own P2P Dendrite into Riot Web by using the Dockerfile at <a href="https://github.com/matrix-org/dendrite/blob/master/build/docker/DendriteJS.Dockerfile">https://github.com/matrix-org/dendrite/blob/master/build/docker/DendriteJS.Dockerfile</a> or following the instructions at  <a href="https://github.com/matrix-org/dendrite/blob/master/docs/p2p.md">https://github.com/matrix-org/dendrite/blob/master/docs/p2p.md</a>.</p>
<p>Please report bugs to <a href="https://github.com/matrix-org/dendrite/issues">https://github.com/matrix-org/dendrite/issues</a>!</p>
<p>Finally, please understand that the demo is very likely <strong>not</strong> what the final version of P2P Matrix will look like - this is just one step in a series of experiments as we investigate the best paths forward :)</p>
<h3 id="what-s-next">What’s next?</h3>
<p>For the current demo, there’s still lots of stuff remaining, including:</p>
<ul>
<li>More federation debugging (and hooking in <a href="https://github.com/matrix-org/tardis">tardis</a> and writing up everything we’ve learned about implementing federation in Dendrite!)</li>
<li>Making the content repository work in-browser (gotta fill up those IndexedDBs with some GIFs!)</li>
<li>Hooking up E2E Encryption APIs in Dendrite (not that it buys us much in a pure P2P world)</li>
<li>WebRTC transports.  Turns out that service workers aren’t allowed to speak WebRTC, so we’ll have to shim through to Riot to speak true peer-to-peer WebRTC data channels rather than relaying all the traffic through the websocket rendezvous server.</li>
<li>Decentralised accounts for multidevice support - reviewing <a href="https://github.com/matrix-org/matrix-doc/blob/rav/proposal/remove_mxids_from_events/proposals/1228-removing-mxids-from-events.md">MSC1228</a> and getting Dendrite supporting multihoming accounts!</li>
<li>Finishing all of Dendrite’s other remaining APIs.</li>
</ul>
<p>Beyond this, there are some bigger picture questions left to be answered in future experiments.</p>
<p>Firstly: we do not yet have a solution for “store and forward” nodes which can relay messages on behalf of a room if all the participating devices are offline.  A first cut will be to run a P2P-capable homeserver server-side for this, but then metadata will start to accumulate server-side for the conversations it hosts.  A more interesting approach would be to use a store and forward system which obfuscates who is talking to who, such as a mixnet, and could even provide resistance to network traffic pattern analysis.  This is very much an open area of research, but one we are getting into :D</p>
<p>Secondly: we want to experiment more with other transports, and find out which works best for Matrix.  Libp2p has some really exciting new stuff in the form of <a href="https://blog.ipfs.io/2020-05-20-gossipsub-v1.1">Gossipsub v1.1</a> - a much smarter routing algorithm for pubsub traffic in libp2p, which David Dias gave us a <a href="https://youtu.be/APVp-20ATLk?t=3598">VIP tour</a> of at the first Open Tech Will Save Us meetup.  So we’ll need to restructure our libp2p transport as pubsub to see how it works in practice.  Separately, we also want to play with hooking up <a href="https://yggdrasil-network.github.io/">Yggdrasil</a> (the encrypted overlay network) as a transport as a totally different approach - Yggdrasil will easily let us span different underlying network transports, but comes with different tradeoffs (e.g. no browser support yet).  We also want to take a look at the <a href="https://dat.foundation/">DAT</a> / <a href="https://github.com/hypercore-protocol/hypercore">hypercore</a> / <a href="https://github.com/hyperswarm/hyperswarm">hyperswarm</a> / <a href="https://cabal.chat/">Cabal</a> ecosystem to see if there’s a match :)</p>
<p>Thirdly and finally: we obviously want to unify the new P2P Matrix network with today’s federated one.  The ideal outcome here would be to have a hybrid model, where teams who want their users to have a dedicated homeserver (for availability, IT policies, etc) can continue to have one as they do today - but newbies who have just installed Riot would float around on P2P unless they decided to consciously put down roots on a server or two.  Best of all, it would let us turn off the matrix.org homeserver: the best public homeserver is one you run yourself on your own phone ;)  The approach we take for linking P2P and today’s Matrix will depend very much on the transport we select for P2P in the long run, but the likelihood is that today’s homeservers will sprout P2P gateways to link the networks.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So, there you have it.  P2P Matrix exists, and is developing at an alarming speed - and pushing Dendrite development along with it.  Most excitingly, there have been no changes yet to the Matrix spec for P2P at all; we’ve just swapped https for http-over-libp2p as the transport.  So <strong>all</strong> of the work we’ve been doing making Dendrite work in a P2P world has directly translated into making Dendrite work on today’s Matrix too  You can now stand up a Dendrite and have it federate pretty reliably with the wider Matrix network, although we’re still rushing through implementing APIs (we’re up to 35% passing <a href="https://github.com/matrix-org/sytest">sytest</a> coverage - although that 35% does contain most of the important tests :)</p>
<p>Finally, in case you’re worried about why the Matrix core team is off chasing P2P dreams rather than improving Riot’s UX, or implementing Communities, or Extensible Profiles, or working through the MSC backlog etc... in practice only two people (ignoring Matthew) have been working on P2P - Neil Alexander (author of the original FOSDEM demo, Dendrite wrangler and Yggdrasil co-maintainer) and Kegan Dougal (of the original Matrix dev team, one of the original authors of Dendrite, and now wrangling the WASM P2P work too).  Huge thanks to Kegan &amp; Neil for pushing P2P forwards - and huge thanks to everyone else on the core team and the wider community for keeping today’s Matrix advancing too!</p>
<p>Hope this has given a tempting glimpse of the shape of things to come.  Honestly we never thought we’d get as far as P2P when we started Matrix back in 2014, but it’s really fun to be finally catching up with the future :D</p>
<p>-- Matthew</p>
<p>P.S. You can read more about this from Neil Alexander’s point of view <a href="https://neilalexander.dev/2020/06/02/thoughts-p2p-matrix.html">over at his blog</a> (including more thoughts on the potential Yggdrasil demo!)</p>
<p>P.P.S You can read the gory details of the P2P and WASM implementation from Kegan's point of view <a href="https://github.com/matrix-org/dendrite/wiki/How-p2p.riot.im-works">over at the Dendrite wiki</a>.</p>
<p>P.P.P.S Comments over at <a href="https://news.ycombinator.com/item?id=23393935">HN</a></p>

                
            </div>
        </article>
        
        <nav class="pagination">
    <div class="prev">
        
        <a href="&#x2F;author&#x2F;matthew-hodgson&#x2F;page&#x2F;2&#x2F;">‹ Previous</a>
        
    </div>
    <span class="page-number">3 / 15</span>
    <div class="prev">
        
        <a href="&#x2F;author&#x2F;matthew-hodgson&#x2F;page&#x2F;4&#x2F;">Next ›</a>
        
    </div>
</nav>

    </div>
</div>

    </main>

    <footer class="site-footer">
    <div class="internal-links">
        
        <a href="&#x2F;faq">FAQs</a>
        
        <a href="&#x2F;security-disclosure-policy">Security Disclosure Policy</a>
        
        <a href="&#x2F;security-hall-of-fame">Security Hall of Fame</a>
        
        <a href="&#x2F;legal&#x2F;code-of-conduct">Code of Conduct for Matrix.org</a>
        
        <a href="&#x2F;legal">Legal</a>
        
        <a href="&#x2F;contact">Contact</a>
        
        <a href="https:&#x2F;&#x2F;github.com&#x2F;matrix-org&#x2F;matrix.org&#x2F;">Site Source</a>
        
    </div>
    <div class="external-links">
        <div>
            
            <a href="https:&#x2F;&#x2F;github.com&#x2F;matrix-org"><img src="/assets/github.svg" alt="GitHub"></a>
            
            <a href="https:&#x2F;&#x2F;gitlab.matrix.org&#x2F;"><img src="/assets/gitlab.svg" alt="GitLab"></a>
            
            <a href="https:&#x2F;&#x2F;mastodon.matrix.org&#x2F;@matrix"><img src="/assets/mastodon.svg" alt="Mastodon"></a>
            
            <a href="https:&#x2F;&#x2F;twitter.com&#x2F;matrixdotorg"><img src="/assets/twitter.svg" alt="Twitter"></a>
            
            <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCVFkW-chclhuyYRbmmfwt6w"><img src="/assets/youtube.svg" alt="YouTube"></a>
            
        </div>
    </div>
    <p>© 2022 The Matrix.org Foundation C.I.C.</p>
</footer>

</body>

</html>
