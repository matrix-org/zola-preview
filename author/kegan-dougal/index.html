<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="twitter:widgets:csp" content="on" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="twitter:site" content="@matrixdotorg" />
    <meta name="twitter:creator" content="@matrixdotorg" />

    <title>Matrix.org - Kegan Dougal</title>
    <link rel="shortcut icon" href="/assets/favicon.ico" />
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />
    <link rel="stylesheet" href="/style.css" />

    
<link rel="alternate" type="application/rss+xml" title="RSS" href="https://matrix.org/author/kegan-dougal/atom.xml">
</head>

<body>
    
    <header class="site-header">
    <a href="/" class="brand">
        <img src="/images/matrix-logo-white.svg" alt="Matrix logo">
    </a>
    <input id="site-header-dropdown-checkbox" type="checkbox" class="dropdown-checkbox" aria-hidden="true">
    <label for="site-header-dropdown-checkbox" class="dropdown-button">&#xe602;</label>
    <label for="site-header-dropdown-checkbox" class="page-overlay"></label>
    <nav>
        
        
        <a href="&#x2F;about&#x2F;" class="
            ">
            About
        </a>
        
        
        
        <a href="&#x2F;blog&#x2F;" class="
            ">
            Blog
        </a>
        
        
        
        <a href="&#x2F;docs&#x2F;" class="
            ">
            Documentation
        </a>
        
        
        
        
        
        <div class="section-wrap">
            <input id="ecosystem-submenu-checkbox" type="checkbox" class="submenu-checkbox" aria-hidden="true"
                >
            <label for="ecosystem-submenu-checkbox" class="submenu-title">Ecosystem <div class="arrow">
                </div></label>

            <div class="section-submenu-wrap">
                <div class="section-submenu">
                    
                    
                    <a href="&#x2F;ecosystem&#x2F;clients&#x2F;">Clients</a>
                    
                    
                    <a href="&#x2F;ecosystem&#x2F;bridges&#x2F;">Bridges</a>
                    
                    
                    <a href="&#x2F;ecosystem&#x2F;servers&#x2F;">Servers</a>
                    
                    <a href="&#x2F;ecosystem&#x2F;integrations&#x2F;">Integrations</a>
                    
                    <a href="&#x2F;ecosystem&#x2F;sdks&#x2F;">SDKs</a>
                    
                    <a href="&#x2F;ecosystem&#x2F;hosting&#x2F;">Hosting</a>
                    
                </div>
            </div>
        </div>
        
        
        
        <a href="&#x2F;podcasts&#x2F;" class="
            ">
            Podcasts
        </a>
        
        
        
        <a href="https:&#x2F;&#x2F;shop.matrix.org" class="
            ">
            Shop
        </a>
        
        
        
        <a href="&#x2F;try-matrix&#x2F;" class="primary
            ">
            Try Matrix
        </a>
        
        
    </nav>
</header>


    <main>
        
<div id="taxonomy-single">
    <div class="content">
        <header>
            <h1>Kegan Dougal</h1>
            7 posts tagged with "Kegan Dougal" <a href="/author">(See all Author)</a>
            
        </header>

        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2021&#x2F;06&#x2F;10&#x2F;low-bandwidth-matrix-an-implementation-guide&#x2F;" title="Low Bandwidth Matrix: An implementation guide">Low Bandwidth Matrix: An implementation guide</a></h2>
                <span>
                    10.06.2021 17:08
                    —
                    <a href="/category/tutorials">
                        Tutorials
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                <br>
                <small>Last update: 10.06.2021 11:28</small>
            </header>
            <div>
                
                <p><em>Disclaimer: Low bandwidth Matrix is experimental, not yet standardised, and subject to change without notice.</em></p>
<p>This guide is for Matrix developers who want to support
<a href="https://github.com/matrix-org/matrix-doc/pull/3079">MSC3079: Low Bandwidth CS API</a> in their
clients/servers. Please read the experimental MSC if you want to learn more about what is happening
at a protocol level. If you want a high level overview of low bandwidth Matrix and why you should
care, watch the <a href="http://www.youtube.com/watch?v=_E-J6Hk2dYs&amp;t=14m14s">12 minute demo on Matrix Live</a>.</p>
<p>Matrix currently uses HTTP APIs with JSON data to communicate from the client to the server. This is
widely supported but is not very bandwidth efficient. This means that the protocol is slower, more
costly and less able to be used on low bandwidth links (e.g 2G networks) which are common in certain
parts of the world. MSC3079 defines a low bandwidth protocol using CoAP and CBOR instead of HTTP and
JSON respectively. In the future homeservers will natively support some form of low bandwidth
protocol. However, at present, no homeserver natively supports MSC3079. Therefore, this guide will
set up a low bandwidth proxy server which can be put in front of any Matrix homeserver
(Synapse, Dendrite, Conduit, etc) to make it MSC3079-compatible. This guide will also configure an
Android device to speak MSC3079.</p>
<p>Low bandwidth Matrix currently does not support web browsers due to their inability to send UDP
traffic. You do <em>not</em> need to be running a homeserver to follow this tutorial.</p>
<h2 id="setting-up-a-low-bandwidth-proxy-for-your-homeserver">Setting up a low bandwidth proxy for your homeserver</h2>
<p>Prerequisites:</p>
<ul>
<li>Go 1.13+</li>
<li><code>openssl</code> to generate a self-signed DTLS certificate, or an existing certificate you want to use.</li>
<li>Linux or Mac user</li>
</ul>
<p>Steps:</p>
<ul>
<li>Clone the repo: <code>git clone https://github.com/matrix-org/lb.git</code></li>
<li>Build the low bandwidth proxy: <code>go build ./cmd/proxy</code></li>
<li>Generate a elliptic curve DTLS key/certificate: (we use curve keys as they are smaller than RSA
keys, but both work.)<pre data-lang="bash" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-bash "><code class="language-bash" data-lang="bash"><span>openssl ecparam -name prime256v1 -genkey -noout -out private-key.pem
</span><span>openssl req -new -x509 -key private-key.pem -out cert.pem -days 365
</span><span style="color:#608b4e;"># you now have cert.pem and private-key.pem
</span></code></pre>
</li>
<li>Run it pointing at matrix.org:<pre data-lang="bash" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-bash "><code class="language-bash" data-lang="bash"><span>./proxy -local </span><span style="color:#d69d85;">&#39;https://matrix-client.matrix.org&#39; </span><span>\
</span><span>--tls-cert cert.pem --tls-key private-key.pem \
</span><span>--advertise </span><span style="color:#d69d85;">&quot;http://127.0.0.1:8008&quot; </span><span>\
</span><span>--dtls-bind-addr :8008
</span></code></pre>
</li>
<li>You should see something like this:<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>INFO[0000] Listening on :8008/tcp to reverse proxy from http://127.0.0.1:8008 to https://matrix-client.matrix.org - HTTPS enabled: false 
</span><span>INFO[0000] Listening for DTLS on :8008 - ACK piggyback period: 5s
</span></code></pre>
</li>
</ul>
<p>Mac users: If you are having trouble generating EC certificates, make sure you are using OpenSSL and
not LibreSSL which comes by default: <code>openssl version</code>. To use OpenSSL, <code>brew install openssl</code> which
then dumps the binary to <code>/usr/local/opt/openssl/bin/openssl</code>.</p>
<p>To test it is working correctly:</p>
<pre data-lang="bash" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#608b4e;"># build command line tools we can use to act as a low bandwidth client
</span><span>go build ./cmd/jc
</span><span>go build ./cmd/coap
</span><span>
</span><span style="color:#608b4e;"># do a CoAP GET request to matrix.org via the proxy
</span><span>./coap -X GET -k </span><span style="color:#d69d85;">&#39;http://localhost:8008/_matrix/client/versions&#39; </span><span style="color:#569cd6;">| </span><span>./jc -c2j </span><span style="color:#d69d85;">&#39;-&#39;
</span><span>
</span><span>{</span><span style="color:#d69d85;">&quot;unstable_features&quot;</span><span>:{</span><span style="color:#d69d85;">&quot;io.element.e2ee_forced.private&quot;</span><span>:false,</span><span style="color:#d69d85;">&quot;io.element.e2ee_forced.public&quot;</span><span>:false,</span><span style="color:#d69d85;">&quot;io.element.e2ee_forced.trusted_private&quot;</span><span>:false,</span><span style="color:#d69d85;">&quot;org.matrix.e2e_cross_signing&quot;</span><span>:true,</span><span style="color:#d69d85;">&quot;org.matrix.label_based_filtering&quot;</span><span>:true,</span><span style="color:#d69d85;">&quot;org.matrix.msc2432&quot;</span><span>:true,</span><span style="color:#d69d85;">&quot;org.matrix.msc3026.busy_presence&quot;</span><span>:false,</span><span style="color:#d69d85;">&quot;uk.half-shot.msc2666&quot;</span><span>:true},</span><span style="color:#d69d85;">&quot;versions&quot;</span><span>:[</span><span style="color:#d69d85;">&quot;r0.0.1&quot;</span><span>,</span><span style="color:#d69d85;">&quot;r0.1.0&quot;</span><span>,</span><span style="color:#d69d85;">&quot;r0.2.0&quot;</span><span>,</span><span style="color:#d69d85;">&quot;r0.3.0&quot;</span><span>,</span><span style="color:#d69d85;">&quot;r0.4.0&quot;</span><span>,</span><span style="color:#d69d85;">&quot;r0.5.0&quot;</span><span>,</span><span style="color:#d69d85;">&quot;r0.6.0&quot;</span><span>]}
</span></code></pre>
<p>If this doesn't work:</p>
<ul>
<li>Check the proxy logs for errors (e.g bad hostname)</li>
<li>Try adding <code>-v</code> to <code>./coap</code> (e.g bad method or path)</li>
<li>Run the proxy with <code>SSLKEYLOGFILE=ssl.log</code> and inspect the decrypted traffic using Wireshark.</li>
</ul>
<p>Otherwise, congratulations! You now have a low bandwidth proxy! You can connect to your proxy just
like you would to matrix.org or any other homeserver.</p>
<h3 id="security-considerations">Security considerations</h3>
<ul>
<li>The proxy acts as a man in the middle and can read all non-E2EE traffic, including login
credentials. DO NOT USE UNTRUSTED LOW BANDWIDTH PROXY SERVERS. Only use proxy servers run by
yourself or the homeserver admins.</li>
</ul>
<h3 id="further-reading">Further reading</h3>
<ul>
<li>The <code>proxy</code> <a href="https://github.com/matrix-org/lb/tree/main/cmd/proxy">README</a></li>
<li><code>coap</code> <a href="https://github.com/matrix-org/lb/tree/main/cmd/coap">README</a> and <code>jc</code>
<a href="https://github.com/matrix-org/lb/tree/main/cmd/jc">README</a></li>
</ul>
<h2 id="setting-up-a-custom-element-android">Setting up a custom Element Android</h2>
<p>We'll add low bandwidth matrix to Element Android and iOS by default once it's standardised - but
while things are still experimental, here's a guide for how to build Element Android to do it
yourself if you feel the urge.  This can be used as inspiration for other Matrix clients too.</p>
<p>Prerequisites:</p>
<ul>
<li>Android Studio</li>
</ul>
<p>Steps:</p>
<ul>
<li>Clone the repo: <code>git clone https://github.com/vector-im/element-android.git</code></li>
<li>Checkout <code>kegan/lb</code>: <code>git checkout kegan/lb</code>. This branch replaces all HTTP traffic going to
<code>/_matrix/client/*</code> with LB traffic. <code>/_matrix/media</code> traffic is left untouched. This branch also
disables TLS checks entirely so self-signed certificates will work.</li>
<li>Clone the low bandwidth repo if you haven't already:
<code>git clone https://github.com/matrix-org/lb.git</code></li>
<li>In the low bandwidth repo, build the mobile bindings:<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>go get golang.org/x/mobile/cmd/gomobile
</span><span>cd mobile
</span><span># if gomobile isn&#39;t on your path, then ~/go/bin/gomobile
</span><span>gomobile bind -target=android
</span></code></pre>
</li>
<li>Copy the output files to a directory in the Element Android repo which Gradle will pick up:<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>mkdir $PATH_TO_ELEMENT_ANDROID_REPO/matrix-sdk-android/libs
</span><span>cp mobile-sources.jar $PATH_TO_ELEMENT_ANDROID_REPO/matrix-sdk-android/libs
</span><span>cp mobile.aar $PATH_TO_ELEMENT_ANDROID_REPO/matrix-sdk-android/libs
</span></code></pre>
</li>
<li>Open the project in Android Studio.</li>
<li>Build and run on a device/emulator.</li>
<li>Configure the proxy's <code>--advertise</code> address. If you are running on a local device, restart the
proxy with an <code>--advertise</code> of your machines LAN IP e.g 192.168.1.2 instead of 127.0.0.1.
If you are running on an emulator, restart the proxy with an <code>--advertise</code> of the
<a href="https://developer.android.com/studio/run/emulator-networking#networkaddresses">host IP</a>:
10.0.2.2. The URL scheme should be <code>https</code> not <code>http</code>, else image loading won't work as Element
Android won't download media over <code>http</code>.</li>
<li>Login to your matrix.org account via the proxy with the <code>--advertise</code> address as the HS URL
e.g <code>https://192.168.1.2:8008</code> or <code>https://10.0.2.2:8008</code>. The port is important.</li>
</ul>
<p>To verify it is running via low bandwidth:</p>
<ul>
<li>Install Wireshark.</li>
<li>Restart the proxy with the environment variable <code>SSLKEYLOGFILE=ssl.log</code>.</li>
<li>Run tcpdump on the right interface e.g: <code>sudo tcpdump -i en0 -s 0 -v port 8008 -w lb.pcap</code> </li>
<li>Force stop the android app to forcibly close any existing DTLS connections.</li>
<li>Re-open the app.</li>
<li>Open <code>lb.pcap</code> in Wireshark and set <code>ssl.log</code> as the Pre-Master Secret log filename via
Preferences -&gt; Protocols -&gt; TLS -&gt; Pre-Master Secret log filename.</li>
<li>Check there is DTLS/CoAP traffic.</li>
</ul>
<h2 id="performance">Performance</h2>
<p>To send a single 'Hello World' message to <code>/room/$room_id/send/m.room.message/$txn_id</code>
and receive the response, including connection setup:</p>
<table><thead><tr><th>Protocol</th><th>Num packets</th><th>Total bytes</th></tr></thead><tbody>
<tr><td>HTTP2+JSON</td><td>43</td><td>6533</td></tr>
<tr><td>CoAP+CBOR</td><td>6</td><td>1440</td></tr>
</tbody></table>
<h2 id="limitations">Limitations</h2>
<ul>
<li>CoAP <a href="https://datatracker.ietf.org/doc/html/rfc7641">OBSERVE</a> is not enabled by default.
This extension allows the server to push data to the client so the client doesn't need to
long-poll. It is not yet enabled because of the risk of state synchronisation issues between the
proxy and the client. If the proxy gets restarted, the client will not receive sync updates
until it refreshes its subscription, which happens infrequently. During this time the client
is not aware that anything is wrong.</li>
<li>CoAP uses <a href="https://datatracker.ietf.org/doc/html/rfc7959">Blockwise Transfer</a> to download
large responses. Each block must be ACKed before the next block can be sent. This is less
efficient than TCP which has a Receive Window which allows multiple in-flight packets at
once. This means CoAP is worse at downloading large responses, requiring more round trips
to completely send the data.</li>
<li>The current version of <code>/sync</code> sends back much more data than is strictly necessary. This
means the initial sync can be slower than expected. On a low kbps link this can flood the
network with so much data that the sync stream begins to fall behind. Future work will look
to optimise the sync API.</li>
<li>The proxy currently doesn't implement the <a href="https://github.com/matrix-org/matrix-doc/blob/kegan/low-bandwidth/proposals/3079-low-bandwidth-csapi.md#versioning">low bandwidth response</a> in <code>/versions</code>.</li>
</ul>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2017&#x2F;03&#x2F;14&#x2F;an-adventure-in-irc-land&#x2F;" title="An Adventure in IRC-Land">An Adventure in IRC-Land</a></h2>
                <span>
                    14.03.2017 00:00
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hi everyone. I'm Kegan, one of the core developers at matrix.org. This is the first in a series on the matrix.org IRC bridge. The aim of this series is to try to give a behind the scenes look at how the IRC bridge works, what kinds of problems we encountered, and how we plan to scale in the future. This post looks at how the IRC bridge actually works.</p>
<p>Firstly, what is &quot;bridging&quot;? The simple answer is that it is a program which maps between different messaging protocols so that users on different protocols can communicate with each other. Some protocols may have features which are not supported in the other (typing notifications in Matrix, DCC - <em>direct</em> file transfers - in IRC). This means that bridging will always be &quot;inferior&quot; to just using the respective protocol. That being said, where there is common ground a bridge can work well; all messaging protocols support sending and receiving text messages for example. As we'll see however, the devil is in the detail...</p>
<p>A lot of existing IRC bridges for different protocols share one thing in common: they use a single global bot to bridge traffic. This bot listens to all messages from IRC, and sends them to the other network. The bot also listens for messages from users on the other network, and sends messages on their behalf to IRC. This is a lot easier than having to maintain dedicated TCP connections for each user. However, it isn't a great experience for IRC users as they:</p>
<ul>
 	<li>Don't know who is reading messages on a channel as there is just 1 bot in the membership list.</li>
 	<li>Cannot PM users on the other network.</li>
 	<li>Cannot kick/ban users on the other network without affecting everyone else.</li>
 	<li>Cannot bing/mention users on the other network easily (tab completion).</li>
</ul>
We made the decision very early on that we would keep dedicated TCP connections for each Matrix user. This means every Matrix user has their own tiny IRC client. This has its own problems:
<ul>
 	<li>It involves multiple connections to the IRCd so you need special permission to set up an i:line.</li>
 	<li>You need to be able to support identification of individual users (via ident or unique IPv6 addresses).</li>
 	<li>With all these connections to the same IRC channels, you need to have some way to identify which incoming messages have already been handled and which have not.</li>
</ul>
<h3 id="mapping-rooms">Mapping Rooms</h3>
<p>So now that we have a way to send and receive messages, how do we map the rooms/channels between protocols? This isn't as easy as you may think. We can have a single static one-to-one mapping:</p>
<ul>
 	<li>All messages to <code>#channel</code> go to <code>!abcdef:matrix.org</code>.</li>
 	<li>All messages from <code>!abcdef:matrix.org</code> go to <code>#channel</code>.</li>
 	<li>All PMs between <code>@alice:matrix.org</code> and Bob go to <code>!wxyz:matrix.org</code> and the respective PM on IRC.</li>
</ul>
In order to make PMs secure, we need to limit who can access the room. This is done by making the Matrix PM room "invite-only". This can cause problems though if the Matrix user ever leaves that room: they won't be able to ever re-join! The IRC bridges get around this by allowing Matrix users to <em>replace</em> their dedicated PM room with a new room, and by checking to make sure that the Matrix user is inside the room before sending messages.
<p>Then you have problem of &quot;ownership&quot; of rooms. Who should be able to kick users in a bridged room? There are two main scenarios to consider:</p>
<ul>
 	<li>The IRC channel has existed for a while and there are existing IRC channel operators.</li>
 	<li>The IRC channel does not exist, but there are existing Matrix moderators.</li>
</ul>
In the first case, we want to defer ownership to the channel operators. This is what happens by default for all bridged IRC channels on matrix.org. The Matrix users have no power in the room, and are at the mercy of the IRC channel operators. The channel operators are represented by virtual Matrix users in the room. However, they do not have any power level: they are at the same level as real Matrix users. Why? The bridge does this because, unlike IRC, it's not possible in Matrix to bring a user to the same level as yourself (e.g <code>+o</code>), and then downgrade them back to a regular user (e.g. <code>-o</code>). Instead, the bridge bot itself acts as a custodian for the room, and performs privileged IRC operations (topic changing, kickbans, etc) on the IRC channel operator's behalf.
<p>In the second case, we want to defer ownership to the Matrix moderators. This is what happens when you &quot;provision a room&quot; in Matrix. The bridge will PM a currently online channel operator and ask for their permission to bridge to Matrix. If they accept, the bridge is made and the power levels in the pre-existing Matrix room are left untouched, giving moderators in Matrix control over the room. However, this power doesn't extend completely to IRC. If a Matrix moderator grants moderator powers to another Matrix user, this will not be mapped to IRC. Why? It's not possible for the bridge to give chanops to any random user on any random IRC channel, so it cannot always honour the request. This relies on the humans on either side of the bridge to communicate and map power accordingly. This is done on purpose as there is no 100% perfect mapping between IRC powers and Matrix powers: it's always going to need to compromise which only a human can make.</p>
<p>Finally, there is the problem of one-to-many mappings. It is possible to have two Matrix rooms bridged to the same IRC channel. The problem occurs when a Matrix user in one room speaks. The bridge can easily map that to IRC, but unless it <em>also</em> maps it back to Matrix, the message will never make it to the 2nd Matrix room. The bridge cannot control/puppet the Matrix user who spoke, so instead it creates a virtual Matrix user to represent that <em>real</em> Matrix user and then sends the message into the 2nd Matrix room. Needless to say, this can be quite confusing and we strongly discourage one-to-many mappings for this reason.</p>
<h3 id="mapping-messages">Mapping Messages</h3>
<p>Mapping Matrix messages to IRC is rather easy for the most part. Messages are passed from the Homeserver to the bridge via the AS API, and the bridge sends a textual representation of the message to IRC using the IRC connection for that Matrix user. The <a href="https://github.com/matrix-org/matrix-appservice-irc/issues/258">exact form</a> of the text for images, videos and long text can be quite subjective, and there is inevitably some data loss along the way. For example, you can send big text headings, tables and lists in Matrix, but there is no equivalent on IRC. Thankfully, most Matrix users are sending the corresponding markdown and so the formatting can be reasonably preserved by just sending the plaintext (markdown) body.</p>
<p>Mapping IRC messages to Matrix is more difficult: not because it's hard to represent the message in Matrix, but because of the architecture of the bridge. The bridge maintains separate connections for each Matrix user. This means the bridge might have, for example, 5 users (and hence connections) on the <em>same channel</em>. When an IRC user sends a message, the bridge gets 5 copies of the message. How does the bridge know:</p>
<ul>
 	<li>If the message has already been sent?</li>
 	<li>If the message is an intentional duplicate?</li>
</ul>
The IRC protocol does not have message IDs, so the bridge cannot de-duplicate messages as they arrive. Instead, it "nominates" a single user's connection to be responsible for delivering messages from that channel. This introduces another problem though. Long-lived TCP connections are fickle things, and can fail without any kind of visible warning until you try to send bytes down it. If a user's connection drops, another user needs to take over responsibility for delivering messages. This is what the "IRC Event Broker" class does. It allows users to "steal" messages if the bridge has any indication that the connection in charge has dropped. This technique has worked well for us, and gives us the ability to have more robust connections to the channel than with one TCP connection alone.
<h3 id="admin-rooms">Admin Rooms</h3>
<p>Admin rooms are private Matrix rooms between a real Matrix user and the bridge bot. It allows the Matrix user to control their connection to IRC. It allows:</p>
<ul>
 	<li>The IRC nick to be changed.</li>
 	<li>The ability to issue /whois commands.</li>
 	<li>The ability to bypass the bridge and send raw IRC commands directly down the TCP connection (e.g. MODE commands).</li>
 	<li>The ability to save a NickServ password for use when the bridge reconnects you.</li>
 	<li>The ability to disconnect from the network entirely.</li>
</ul>
To perform these actions, Matrix users send a text message which starts with a command name, e.g <code>!whois $ARG</code>. Like all commands, you expect to get a reply once you've issued it. However, IRC makes this extremely difficult to do. There is no request/response pair like there is with HTTP requests. Instead, the IRC server may:
<ul>
 	<li>Ignore the request entirely.</li>
 	<li>Send an error you're aware of (in the RFC/most servers)</li>
 	<li>Send some information which can be assumed to indicate success.</li>
 	<li>Send an error you're unaware of.</li>
 	<li>Send some information which <em>sometimes</em> indicates success.</li>
</ul>
This makes it very difficult to know if a request succeeded or failed, and I'll go into more detail in the next post which focuses on problems we've encountered when developing the IRC bridge. This room is also used to inform the Matrix user about general information about their IRC connection, such as when their connection has been lost, or if there are any errors (e.g. "requires chanops to do this action"). The bridge makes no effort to parse these errors, because it doesn't always know what caused the error to happen.
<h3 id="wrapup">Wrapup</h3>
<p>Developing a comprehensive IRC bridge is a very difficult task. This post has outlined a few of the ways in which we've designed our bridge, and some of the general problems in this field. The bridge is constantly improving as we discover new edge cases with the plethora of IRCd implementations out there. The next post will look at some of these edge cases and look back at some previous outages and examine why they occurred.</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2017&#x2F;03&#x2F;06&#x2F;new-bridged-irc-network-gimpnet&#x2F;" title="New bridged IRC network: GIMPNet">New bridged IRC network: GIMPNet</a></h2>
                <span>
                    06.03.2017 00:00
                    —
                    <a href="/category/general">
                        General
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>Hey everyone! As of last week, we are now bridging irc.gimp.org (GIMPNet) for all your GTK+/GNOME needs! It's running a bleeding-edge version of the IRC bridge which supports basic chanops syncing from IRC to Matrix. This means that if an IRC user gives chanops to a Matrix connection, the bridge will give that Matrix user moderator privileges in the room, allowing them to set the room topic/avatar/alias/etc! We hope this will make customising Matrix-bridged rooms a lot easier.</p>
<p>For a more complete list of current and future bridged IRC networks, see the <a href="https://github.com/matrix-org/matrix-appservice-irc/issues/208">official wishlist</a>.</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2016&#x2F;08&#x2F;15&#x2F;matrix-irc-bridge-reaches-v0-4-0&#x2F;" title="Matrix-IRC Bridge reaches v0.4.0">Matrix-IRC Bridge reaches v0.4.0</a></h2>
                <span>
                    15.08.2016 00:00
                    —
                    <a href="/category/tech">
                        Tech
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>A new version of the IRC bridge has been released onto NPM and the matrix.org bridges!</p>
<p>The IRC bridge has undergone quite a number of modifications since its <a href="/blog/2015/04/22/matrix-irc-application-service/">original inception</a> over a year ago. Version 0.4 introduces a number of additional features and improvements, which can be found in the <a href="https://github.com/matrix-org/matrix-appservice-irc/blob/master/CHANGELOG.md">changelog</a>. These include automatically linkifying large blocks of text and mirroring kicks/bans to and from Matrix.</p>
<p>With a plethora of protocol gotchas and non-standard features on well-known IRC networks, IRC is a challenging protocol to work with. It's inevitable that some corner cases are not handled well by the bridge. Over time, the bridge has been hardened by edge cases which we have encountered and patched. These releases signify the continual improvement in the robustness of the bridge, which we aim to continue with into the foreseeable future.</p>
<p>Performance wise, our busiest bridge which we host is the bridge to <a href="http://freenode.net/">Freenode</a>. We now have over 1300 active connections to it and have a steady rate of about 240 messages per minute going through to Matrix. We expect to see this number increase significantly over the next few months. Let's see what the next year will bring!</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2015&#x2F;07&#x2F;29&#x2F;micropub-support-as-an-application-service&#x2F;" title="Micropub support as an Application Service!">Micropub support as an Application Service!</a></h2>
                <span>
                    29.07.2015 00:00
                    —
                    <a href="/category/tech">
                        Tech
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                
            </header>
            <div>
                
                <p>I was at <a href="http://indiewebcamp.com/2015/Edinburgh">IndieWebCamp Edinburgh</a> last week and during the hack day I <a href="https://github.com/Kegsay/matrix-as-micropub">created a Matrix Application Service</a> (AS) which could act as an IndieWeb <a href="http://indiewebcamp.com/Micropub">Micropub</a> client. Any Matrix message sent to the AS (<code>@micropub:domain</code>) would be converted to a request to a Micropub endpoint.</p>
<p>This required the AS to support <a href="http://indiewebcamp.com/IndieAuth">IndieAuth</a> - which it does by sending <code>!indieauth http://yourdomain.dom</code> to <code>@micropub:domain</code> which then returns an OAuth2 URL to login via. Currently, the AS just supports a 1:1 mapping from <code>m.text</code> to <code>h:entry</code> but in the future, it can be expanded to include categories and potentially the reverse mapping (where Micropub clients can act as Matrix users!).</p>
<p>Overall, it was a <a href="http://rhiaro.co.uk/2015/07/indiewebcamp-edinburgh-closes">great weekend</a> and I look forward to adding more support for IndieWeb protocols in the future.</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2015&#x2F;04&#x2F;22&#x2F;matrix-irc-application-service&#x2F;" title="The All New Matrix-IRC Application Service">The All New Matrix-IRC Application Service</a></h2>
                <span>
                    22.04.2015 00:00
                    —
                    <a href="/category/tech">
                        Tech
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                
            </header>
            <div>
                
                <p><strong>This post has now been edited into a guide - you can find <a href="https://github.com/matrix-org/matrix-doc/blob/master/supporting-docs/guides/2015-08-21-application_services.md">the source in github</a>, and the <a href="http://matrix.org/docs/guides/application_services.html">formatted guide on the matrix.org website</a>!</strong></p>
<hr />
<p>Like a lot of open source projects, we use IRC a lot. Naturally, we also use Matrix to communicate with each other. For some time now we've had an IRC bot sitting on specific channels to &quot;bridge&quot; together IRC and Matrix. This bot simply sent IRC messages when it received Matrix messages and vice versa. As we started to rely on it more and more though, we realised that there were things that were impossible for simple client-side bots to do by themselves. This spurred the development of Application Services which <a href="/blog/2015/03/02/introduction-to-application-services/">I introduced in my previous post</a>. In this blog post, I want to outline some of the features and techniques of the IRC application service which we've been working on over the past few weeks.</p>
<p>Features:</p>
<ul>
	<li><strong>Specific channel-to-matrix room bridging</strong> : This is what the original IRC bot did. You can specify specific channels and specific room IDs, and messages will be bridged.</li>
	<li><strong>Dynamic channel-to-matrix room bridging</strong> : This allows Matrix users to join any channel on an IRC network, rather than being forced to use one of the specific channels configured.</li>
	<li><strong>Two-way PM support</strong> : IRC users can PM the virtual "M-" users and private Matrix rooms will be created. Likewise, Matrix users can invite the virtual "@irc_Nick:domain" user IDs to a room and a PM to the IRC nick will be made.</li>
	<li><strong>IRC nick changing support </strong>: Matrix users are no longer forced to use "M-" nicks and can change them by sending "!nick" messages directly to the bridge.</li>
	<li><strong>Ident support</strong> : This allows usernames to be authenticated for virtual IRC clients, which means IRC bans can be targeted at the Matrix user rather than the entire application service.</li>
</ul>
The use of the Application Services API means:
<ul>
	<li>The bot can reserve user IDs. This prevents humans from registering for @irc_... user IDs which would then clash with the operation of the bot.</li>
	<li>The bot can reserve room aliases. This prevents humans from register for #irc_... aliases which would then clash with the operation of the bot.</li>
	<li>The bot can trivially manage hundreds of users. Events are pushed to the application service directly. If you tried to do this as a client-side bot, you would need one event stream connection per virtual user.</li>
	<li>The bot can lazily create rooms on demand. This means Matrix users can join non-existent room aliases and have the application service quickly track an IRC channel and create a room with that alias, allowing the join request to succeed.</li>
</ul>
Implementation details:
<ul>
	<li>Written in Node.js, designed to be run using <code>forever</code>.</li>
        <li>Built on the generic <a href="http://github.com/matrix-org/matrix-appservice-node">matrix-appservice-node</a> framework.</li>
	<li>Supports sending metrics in statsd format.</li>
	<li>Uses matrix-appservice-node to provide a standardised interface when writing application services, rather than an explicit web framework (though under the hood matrix-appservice-node is using Express).</li>
</ul>
At present, the IRC application service is in beta, and is being run on #matrix and #matrix-dev. If you want to give it a go, <a title="Matrix-IRC Application Service" href="https://github.com/matrix-org/matrix-appservice-irc">check it out on Github</a> - it is not currently released on npm. <b>N.B. it requires features from the develop branch of synapse; either run your own synapse off the develop branch or wait a few days for us to release Synapse 0.9.0</b>.
<p>Needless to say, we look forward to this being the first of many full network&lt;-&gt;network bridges into Matrix - come chat on <a href="/beta/#/room/#matrix:matrix.org">#matrix:matrix.org</a> if you'd like to write or run your own!  Next up is Lync and XMPP...</p>

                
            </div>
        </article>
        
        <article class="post">
            <header>
                <h2><a href="https:&#x2F;&#x2F;matrix.org&#x2F;blog&#x2F;2015&#x2F;03&#x2F;02&#x2F;introduction-to-application-services&#x2F;" title="Introduction to Application Services">Introduction to Application Services</a></h2>
                <span>
                    02.03.2015 00:00
                    —
                    <a href="/category/tutorials">
                        Tutorials
                    </a>
                    —
                    <a
                        href="/author/kegan-dougal">
                        Kegan Dougal
                    </a>
                </span>
                
            </header>
            <div>
                
                <p><strong>This post has now been edited into a guide - you can find <a href="https://github.com/matrix-org/matrix-doc/blob/master/supporting-docs/guides/2015-08-21-application_services.md">the source in github</a>, and the <a href="http://matrix.org/docs/guides/application-services">formatted guide on the matrix.org website</a>!</strong></p>
<hr />
<p>Hi everyone. I'm Kegan, one of the core developers on Matrix. I'd like to explain a bit more about one of the upcoming features in Matrix: Application Services. This is an entirely new component in the Matrix architecture which gives great power (along with great responsibility!) to the wielder.</p>
<p>Application services are distinct modules which which sit alongside a home server providing arbitrary extensible functionality decoupled from the home server implementation. Just like the rest of Matrix, they communicate via HTTP using JSON. Application services function in a very similar way to traditional clients, but they are given much more power than a normal client. They can reserve entire namespaces of room aliases and user IDs for their own purposes. They can silently monitor events in rooms, or any events directed at any user ID. This power allows application services to have extremely useful abilities which overall enhance the end user experience.</p>
<p>One of the main use cases for application services is for protocol bridges. As you may know, we have an IRC bridge bot on matrix.org which resides as a user on #matrix, #matrix-dev, #openwebrtc and #vuc which bridges into freenode. There is nothing special about this bot; it is just treated as a client. However, this limits the things the bot can do. For example, the bot cannot reserve the virtual user IDs it creates, and cannot lazily bridge arbitrary IRC rooms on-the-fly. By using application services, the IRC bot can do both of these things. This would allow any Matrix user to join a room alias which doesn't exist: say <code>#irc.freenode.python:matrix.org</code>, which would then tell the application service to create a new Matrix room, make the alias for it, join #python on freenode and bridge into it. Any IRC user on #python would then be provisioned as a virtual user e.g. <code>@irc.freenode.alice:matrix.org</code>. This also allows PMs to be sent directly to <code>@irc.freenode.alice:matrix.org</code>, no matter what channel Alice is on.</p>
<p>Application services have enormous potential for creating new and exciting ways to transform and enhance the core Matrix protocol. For example, you could aggregate information from multiple rooms into a summary room, or create throwaway virtual user accounts to proxy messages for a fixed user ID on-the-fly. As you may expect, all of this power assumes a high degree of trust between application services and home servers. Only home server admins can allow an application service to link up with their home server, and the application service is in no way federated to other home servers. You can think of application services as additional logic on the home server itself, without messing around with the book-keeping that home servers have to do. This makes adding useful functionality very easy.</p>
<p><strong>Example</strong></p>
<p>The application service (AS) API itself uses webhooks to communicate from the home server to the AS:</p>
<ul>
<li>Room Alias Query API : The home server hits a URL on your application server to see if a room alias exists.</li>
<li>User Query API : The home server hits a URL on your application server to see if a user ID exists.</li>
<li>Push API : The home server hits a URL on your application server to notify you of new events for your users and rooms.</li>
</ul>
<p>A very basic application service may want to log all messages in rooms which have an alias starting with &quot;#logged_&quot; (side note: logging won't work if these rooms are using end-to-end encryption).</p>
<p>Here's an example of a very basic application service using Python (with Flask and Requests) which logs room activity:</p>
<pre># app_service.py:

import json, requests  # we will use this later
from flask import Flask, jsonify, request
app = Flask(__name__)

@app.route("/transactions/&lt;transaction&gt;", methods=["PUT"])
def on_receive_events(transaction):
    events = request.get_json()["events"]
    for event in events:
        print "User: %s Room: %s" % (event["user_id"], event["room_id"])
        print "Event Type: %s" % event["type"]
        print "Content: %s" % event["content"]
    return jsonify({'{'}{'}'})

if __name__ == "__main__":
    app.run()
</pre>
<p>Set your new application service running on port 5000 with:</p>
<pre>python app_service.py
</pre>
<p>The home server needs to know that the application service exists before it will send requests to it. This is done via a registration YAML file which is specified in Synapse's main config file e.g. <code>homeserver.yaml</code>. The server admin needs to add the application service registration configuration file as an entry to this file.</p>
<pre># homeserver.yaml
app_service_config_files:
  - "/path/to/appservice/registration.yaml"
</pre>
<p>NB: Note the &quot;-&quot; at the start; this indicates a list element. The registration file <code>registration.yaml</code> should look like:</p>
<pre># registration.yaml

# this is the base URL of the application service
url: "http://localhost:5000"

# This is the token that the AS should use as its access_token when using the Client-Server API
# This can be anything you want.
as_token: wfghWEGh3wgWHEf3478sHFWE

# This is the token that the HS will use when sending requests to the AS.
# This can be anything you want.
hs_token: ugw8243igya57aaABGFfgeyu

# this is the local part of the desired user ID for this AS (in this case @logging:localhost)
sender_localpart: logging
namespaces:
  users: []
  rooms: []
  aliases:
    - exclusive: false
      regex: "#logged_.*"
</pre>
<p><strong>You will need to restart the home server after editing the config file before it will take effect.</strong></p>
<p>To test everything is working correctly, go ahead and explicitly create a room with the alias &quot;#logged_test:localhost&quot; and send a message into the room: the HS will relay the message to the AS by PUTing to /transactions/&lt;tid&gt; and you should see your AS print the event on the terminal. This will monitor any room which has an alias prefix of &quot;#logged_&quot;, but it won't lazily create room aliases if they don't already exist. This means it will only log messages in the room you created before: #logged_test:localhost. Try joining the room &quot;#logged_test2:localhost&quot; without creating it, and it will fail. Let's fix that and add in lazy room creation:</p>
<pre>@app.route("/rooms/&lt;alias&gt;")
def query_alias(alias):
    alias_localpart = alias.split(":")[0][1:]
    requests.post(
        # NB: "TOKEN" is the as_token referred to in registration.yaml
        "<a href="http://localhost:8008/_matrix/client/api/v1/createRoom?access_token=TOKEN" target="_blank">http://localhost:8008/_matrix/client/api/v1/createRoom?access_token=TOKEN</a>",
        json.dumps({'{'}
            "room_alias_name": alias_localpart
        {'}'}),
        headers={'{'}"Content-Type":"application/json"{'}'}
    )
    return jsonify({'{'}{'}'})
</pre>
<p>This makes the application service lazily create a room with the requested alias whenever the HS queries the AS for the existence of that alias (when users try to join that room), allowing any room with the alias prefix #logged_ to be sent to the AS. Now try joining the room &quot;#logged_test2:localhost&quot; and it will work as you'd expect.  You can see that if this were a real bridge, the AS would have checked for the existence of #logged_test2 in the remote network, and then lazily-created it in Matrix as required.</p>
<p>Application services are powerful components which extend the functionality of home servers, but they are limited. They can only ever function in a &quot;passive&quot; way. For example, you cannot implement an application service which censors swear words in rooms, because there is no way to prevent the event from being sent. Aside from the fact that censoring will not work when using end-to-end encryption, all federated home servers would also need to reject the event in order to stop developing an inconsistent event graph. To &quot;actively&quot; monitor events, another component called a &quot;Policy Server&quot; is required, which is beyond the scope of this post.  Also, Application Services can result in a performance bottleneck, as all events on the homeserver must be ordered and sent to the registered application services.  If you are bridging huge amounts of traffic, you may be better off having your bridge directly talk the Server-Server federation API rather than the simpler Application Service API.</p>
<p>I hope this post demonstrates how easy it is to create an application service, along with a few ideas of the kinds of things you can do with them. Obvious uses include build protocol bridges, search engines, invisible bots, etc. For more information on the AS HTTP API, check out the new <a href="http://matrix.org/docs/spec/#application-service-api">Application Service API</a> section in the spec, or the raw drafts and spec in <a href="https://github.com/matrix-org/matrix-doc/" target="_blank">https://github.com/matrix-org/matrix-doc/</a>.  The AS API is not yet frozen, so feedback is very welcome!</p>

                
            </div>
        </article>
        
        <nav class="pagination">
    <div class="prev">
        
    </div>
    <span class="page-number">1 / 1</span>
    <div class="prev">
        
    </div>
</nav>

    </div>
</div>

    </main>

    <footer class="site-footer">
    <div class="internal-links">
        
        <a href="&#x2F;faq">FAQs</a>
        
        <a href="&#x2F;security-disclosure-policy">Security Disclosure Policy</a>
        
        <a href="&#x2F;security-hall-of-fame">Security Hall of Fame</a>
        
        <a href="&#x2F;legal&#x2F;code-of-conduct">Code of Conduct for Matrix.org</a>
        
        <a href="&#x2F;legal">Legal</a>
        
        <a href="&#x2F;contact">Contact</a>
        
        <a href="https:&#x2F;&#x2F;github.com&#x2F;matrix-org&#x2F;matrix.org&#x2F;">Site Source</a>
        
    </div>
    <div class="external-links">
        <div>
            
            <a href="https:&#x2F;&#x2F;github.com&#x2F;matrix-org"><img src="/assets/github.svg" alt="GitHub"></a>
            
            <a href="https:&#x2F;&#x2F;gitlab.matrix.org&#x2F;"><img src="/assets/gitlab.svg" alt="GitLab"></a>
            
            <a href="https:&#x2F;&#x2F;mastodon.matrix.org&#x2F;@matrix"><img src="/assets/mastodon.svg" alt="Mastodon"></a>
            
            <a href="https:&#x2F;&#x2F;twitter.com&#x2F;matrixdotorg"><img src="/assets/twitter.svg" alt="Twitter"></a>
            
            <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCVFkW-chclhuyYRbmmfwt6w"><img src="/assets/youtube.svg" alt="YouTube"></a>
            
        </div>
    </div>
    <p><a href="/legal/copyright-notice">Copyright Notice</a></p>
</footer>

</body>

</html>
